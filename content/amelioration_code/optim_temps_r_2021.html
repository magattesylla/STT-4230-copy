---
title: "Optimisation de temps d'exécution en R"
linkTitle: "Optimisation temps exécution R"
author: "Sophie Baillargeon, Université Laval"
date: "2021-04-03"
weight: 2
slug: "optim_temps_r"
lastmodifierdisplayname: "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
bibliography: ../references.bib
csl: ../custom.csl
link-citations: true
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
- \usepackage{ragged2e}
editor_options: 
  chunk_output_type: console
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#outils-danalyse-de-la-performance-dun-programme-r"><span class="toc-section-number">1</span> Outils d’analyse de la performance d’un programme R</a>
<ul>
<li><a href="#fonction-system.time"><span class="toc-section-number">1.1</span> Fonction <code>system.time</code></a></li>
<li><a href="#package-bench"><span class="toc-section-number">1.2</span> Package <code>bench</code></a></li>
<li><a href="#liens-entre-gestion-de-la-mémoire-et-temps-dexécution"><span class="toc-section-number">1.3</span> Liens entre gestion de la mémoire et temps d’exécution</a>
<ul>
<li><a href="#récupération-de-mémoire"><span class="toc-section-number">1.3.1</span> Récupération de mémoire</a></li>
</ul></li>
<li><a href="#fonctions-rprof-et-summaryrprof"><span class="toc-section-number">1.4</span> Fonctions <code>Rprof</code> et <code>summaryRprof</code></a></li>
<li><a href="#package-profvis"><span class="toc-section-number">1.5</span> Package <code>profvis</code></a></li>
</ul></li>
<li><a href="#stratégies-doptimisation-du-temps-dexécution"><span class="toc-section-number">2</span> Stratégies d’optimisation du temps d’exécution</a>
<ul>
<li><a href="#astuce-1-utiliser-des-fonctions-optimisées"><span class="toc-section-number">2.1</span> Astuce 1 : Utiliser des fonctions optimisées</a></li>
<li><a href="#astuce-2-faire-seulement-ce-qui-est-nécessaire"><span class="toc-section-number">2.2</span> Astuce 2 : Faire seulement ce qui est nécessaire</a></li>
<li><a href="#astuce-3-exploiter-les-calculs-matriciels-et-vectoriels"><span class="toc-section-number">2.3</span> Astuce 3 : Exploiter les calculs matriciels et vectoriels</a></li>
<li><a href="#astuce-4-éviter-les-allocations-de-mémoire-inutiles"><span class="toc-section-number">2.4</span> Astuce 4 : Éviter les allocations de mémoire inutiles</a>
<ul>
<li><a href="#objets-de-dimension-croissante"><span class="toc-section-number">2.4.1</span> Objets de dimension croissante</a></li>
<li><a href="#modification-déléments-dans-un-data-frame"><span class="toc-section-number">2.4.2</span> Modification d’éléments dans un data frame</a></li>
</ul></li>
<li><a href="#astuce-5-faire-du-calcul-en-parallèle"><span class="toc-section-number">2.5</span> Astuce 5 : Faire du calcul en parallèle</a></li>
<li><a href="#astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents"><span class="toc-section-number">2.6</span> Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</a></li>
</ul></li>
<li><a href="#résumé"><span class="toc-section-number">3</span> Résumé</a></li>
<li><a href="#références">Références</a></li>
</ul>
</div>

<hr />
<p><em>Note préliminaire : Lors de leur dernière mise à jour, ces notes ont été révisées en utilisant R version 4.0.3, le package <code>bench</code> version 1.1.1 (et le package <code>beeswarm</code> version 0.3.1 utilisé par la méthode <code>plot.bench_mark</code>), le package <code>profvis</code> version 0.3.7, le package <code>data.table</code> version 1.13.6 et le package <code>parallel</code> version 4.0.3. Pour d’autres versions, les informations peuvent différer.</em></p>
<hr />
<p>Lorsque nous écrivons du code, notre but premier est évidemment que ce code fonctionne correctement. Après avoir vérifié que le code <a href="https://stt4230.rbind.io/programmation/tests_exceptions_r/">produit les résultats escomptés et gère correctement les exceptions</a>, nous devrions, selon les <a href="https://stt4230.rbind.io/amelioration_code/bonnes_pratiques_r/">bonnes pratiques</a>, nous assurer que le code est facile à maintenir (écriture, compréhension et réutilisation aisées). Si notre code remplit toutes les conditions énumérées ci-dessus, mais que son temps d’exécution est long, nous devrions envisager de le rendre plus rapide, sans quoi il risque d’être peu ou pas utilisé. Cependant, n’oublions pas qu’il est inutile d’optimiser le temps d’exécution d’un programme roulant déjà suffisamment rapidement.</p>
<p>Pour réduire le temps d’exécution d’un programme, il faut d’abord cerner la partie du programme responsable des lenteurs. Pour ce faire, il est conseillé d’utiliser des outils qui analysent la performance du code. Après avoir cerné les instructions problématiques, il faut les modifier de façon à effectuer le calcul plus rapidement. Certains outils d’analyse de performance sont présentés dans ce qui suit. Ensuite, nous verrons des stratégies d’optimisation de temps d’exécution.</p>
<div id="outils-danalyse-de-la-performance-dun-programme-r" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Outils d’analyse de la performance d’un programme R</h1>
<p>Une analyse de la performance d’un programme informatique est appelée <a href="https://fr.wikipedia.org/wiki/Profilage_de_code">profilage de code</a> (en anglais <em>code profiling</em>). Il est possible de profiler l’utilisation du processeur et l’utilisation de la mémoire. Nous nous attarderons surtout ici au profilage de l’utilisation du processeur, qui vise principalement à évaluer le temps d’exécution d’un programme. Cependant, nous parlerons aussi un peu de profilage d’utilisation de la mémoire, car la gestion de la mémoire a un impact sur le temps d’exécution.</p>
<p>Le R de base propose deux outils pour effectuer du profilage d’utilisation du processeur :</p>
<ul>
<li>la fonction <code>system.time</code> : pour le calcul de temps global d’exécution;</li>
<li>les fonctions <code>Rprof</code> et <code>summaryRprof</code> : pour décortiquer la provenance des lenteurs dans un code R.</li>
</ul>
<p>Cependant, ces fonctions sont souvent insuffisantes pour réaliser une analyse approfondie. Nous utiliserons aussi les packages suivants :</p>
<ul>
<li><code>bench</code> : pour le calcul de temps global d’exécution et un suivi de la gestion de la mémoire;</li>
<li><code>profvis</code> : pour visualiser le résultat produit par <code>Rprof</code>.</li>
</ul>
<p>Pour illustrer l’utilisation de ces fonctions, nous allons reprendre un exemple des <a href="https://stt4230.rbind.io/programmation/fonctions_r/#exemple-de-cr%C3%A9ation-dune-fonction-r">notes sur les fonctions en R</a>. Nous avions créé les deux fonctions suivantes pour compter combien de nombres entiers impairs contient un vecteur numérique <span class="citation">[<a href="#ref-matloff" role="doc-biblioref">1</a>]</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Compte le nombre d&#39;entiers impairs dans un vecteur numérique</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version avec calcul vectoriel</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param x vecteur numérique</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return le nombre de nombres entiers impairs dans x</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>compte_impair_vectoriel <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>(x <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit compte_impair_vectoriel title params return</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version avec boucle</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>compte_impair_boucle <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  k <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> x) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (n <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>      k <span class="ot">&lt;-</span> k <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  k</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Des <a href="https://stt4230.rbind.io/packages/devel_packages_r/#documentation-avec-roxygen2">tags <code>roxygen2</code></a> sont utilisés pour documenter les fonctions. Cependant, les commentaires <code>roxygen</code> écrits ici ne formeraient pas des fiches d’aide complètes. Ce n’est pas un problème puisque nous n’avons pas l’intention de créer un package avec ces fonctions. Notons que le <a href="https://roxygen2.r-lib.org/articles/rd.html#do-repeat-yourself">tag <code>@inherit</code></a> permet de reprendre telles quelles des sections d’une autre fiche d’aide, ici le titre, la description des arguments et de la sortie.</p>
<p>Avant de profiler ces fonctions, assurons-nous qu’elles retournent le même résultat. Pour ce faire, donnons-leur en entrée un vecteur <code>obs</code> contenant un million d’observations générées aléatoirement.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Génération aléatoire d&#39;un million d&#39;observations</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>obs <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fu">runif</span>(<span class="dv">1000000</span>, <span class="sc">-</span><span class="dv">10</span>, <span class="dv">10</span>))</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Appels aux fonctions à comparer</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>compte_1 <span class="ot">&lt;-</span> <span class="fu">compte_impair_vectoriel</span>(<span class="at">x =</span> obs)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>compte_2 <span class="ot">&lt;-</span> <span class="fu">compte_impair_boucle</span>(<span class="at">x =</span> obs)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Comparaison des sorties retournées</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>compte_1 <span class="sc">==</span> compte_2</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Les deux fonctions retournent bien dans cet exemple la même valeur numérique. Notons cependant que la première fonction (<code>compte_impair_vectoriel</code>) retourne le résultat sous la forme d’un entier (<em>integer</em>) et la deuxième (<code>compte_impair_boucle</code>) sous la forme d’un réel (<em>double</em>). Cette différence de type de donnée retournée n’est pas un problème ici.</p>
<div id="fonction-system.time" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Fonction <code>system.time</code></h2>
<p>Mesurons combien de temps prennent les exécutions d’appels aux fonctions <code>compte_impair_vectoriel</code> et <code>compte_impair_boucle</code> lorsque nous leur donnons en entrée le vecteur <code>obs</code>. Pour ce faire, utilisons d’abord la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/system.time.html">fonction <code>system.time</code></a>, comme nous l’avions fait dans les <a href="https://stt4230.rbind.io/programmation/fonctions_r/#exemple-de-cr%C3%A9ation-dune-fonction-r">notes sur les fonctions en R</a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>temps_1 <span class="ot">&lt;-</span> <span class="fu">system.time</span>(compte_1 <span class="ot">&lt;-</span> <span class="fu">compte_impair_vectoriel</span>(<span class="at">x =</span> obs))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>temps_2 <span class="ot">&lt;-</span> <span class="fu">system.time</span>(compte_2 <span class="ot">&lt;-</span> <span class="fu">compte_impair_boucle</span>(<span class="at">x =</span> obs))</span></code></pre></div>
<p>Il faut donner en entrée à <code>system.time</code> une instruction R, contenant ou non une assignation, ou encore des instructions R encadrées d’accolades. Cet ensemble d’instruction(s) est appelé <em>expression</em>. La fonction retourne le temps, en secondes, d’utilisation du CPU (<em>Central Processing Unit</em>) pour l’exécution de l’expression. Notons que le terme « exécution » pourrait être remplacé par le terme « évaluation ». Ils ont ici la même signification.</p>
<p>J’obtiens les temps suivants, qui indiquent que <code>compte_impair_vectoriel</code> est plus rapide que <code>compte_impair_boucle</code> :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>temps_1</span></code></pre></div>
<pre><code>##    user  system elapsed 
##    0.00    0.01    0.03</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>temps_2</span></code></pre></div>
<pre><code>##    user  system elapsed 
##    0.23    0.02    0.25</code></pre>
<p>Les trois temps dans une sortie produite par <code>system.time</code> peuvent être définis ainsi :</p>
<ul>
<li><code>user</code> : temps écoulé par le logiciel R (<em>calling process</em>) pour évaluer l’expression;</li>
<li><code>system</code> : temps écoulé par le système d’exploitation de notre ordinateur, mais pour le compte du logiciel R, pendant l’exécution de l’expression;</li>
<li><code>elapsed</code> : temps total écoulé entre la soumission de l’expression et le retour du résultat (possiblement plus grand que la somme des deux autres temps, car le système a peut-être dû accorder du temps à d’autres processus actifs sur l’ordinateur pendant l’exécution de l’expression)</li>
</ul>
<p>Les temps d’exécution obtenus dépendent des spécifications de l’ordinateur utilisé, en particulier de la puissance de son CPU. De plus, nous n’obtiendrons probablement pas exactement les mêmes temps si nous évaluons à nouveau l’expression. Il y a une petite variation normale du temps d’exécution, causée notamment par les autres processus utilisant le CPU de notre ordinateur au moment où la commande est lancée.</p>
</div>
<div id="package-bench" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Package <code>bench</code></h2>
<p>La fonction <code>system.time</code> est plutôt minimaliste. Elle mesure le temps pris par une seule exécution d’une expression. Pour évaluer plus justement le temps d’exécution d’une expression, il est préférable de l’exécuter à quelques reprises, puis de calculer le temps médian d’exécution. La médiane est plus appropriée que la moyenne pour cette mesure de tendance centrale, car elle est robuste aux valeurs extrêmes, qui ne sont pas si rares parmi des temps d’exécution. Aussi, étant donné qu’il y a un lien entre le temps d’exécution et la gestion de la mémoire, il serait pertinent de récolter, en plus du temps, des informations concernant la mémoire utilisée pendant les exécutions. Voilà le but du <a href="http://bench.r-lib.org/">package <code>bench</code></a>. Dans ces notes, nous allons utiliser la <a href="http://bench.r-lib.org/reference/mark.html">fonction <code>mark</code></a> de ce package pour effectuer du profilage de plusieurs fonctions R.</p>
<p>Comparativement à la fonction <code>system.time</code>, la fonction <code>mark</code> possède plusieurs avantages, notamment :</p>
<ul>
<li>profilage de plus d’une expression à la fois;</li>
<li>chronométrage plus précis grâce aux répétitions et à une unité de mesure de temps plus fine;</li>
<li>suivi de la gestion de la mémoire.</li>
</ul>
<p>Voici un premier exemple d’utilisation de cette fonction :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bench)</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sortie_mark <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">vectoriel =</span> <span class="fu">compte_impair_vectoriel</span>(obs), </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">boucle =</span> <span class="fu">compte_impair_boucle</span>(obs)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<p>Un avertissement a été émis. Nous y reviendrons.</p>
<p>Il faut fournir en entrée à cette fonction une série d’expressions à profiler (ce pourrait être une seule expression). Ces expressions sont à fournir en arguments distincts, attrapés par l’argument <code>...</code>, qui permet le passage d’autant d’expressions à profiler que souhaité. Les expressions peuvent être assignées à des noms avec l’opérateur <code>=</code> (comme dans l’exemple), ou non. Le nom fourni à gauche de l’opérateur <code>=</code> pour une expression est celui utilisé pour identifier l’expression dans la sortie, ce qui peut aider à alléger l’affichage des résultats.</p>
<p>La sortie retournée par la fonction <code>mark</code> a un format particulier. Il s’agit d’un objet possédant 4 classes, dont celle de data frame, mais pour lequel les éléments ne sont pas tous de simples vecteurs ou facteur.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(sortie_mark)</span></code></pre></div>
<pre><code>## [1] &quot;bench_mark&quot; &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>sortie_mark</span></code></pre></div>
<pre><code>## # A tibble: 2 x 13
##   expression   min  median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result
##   &lt;bch:expr&gt; &lt;bch&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;   &lt;bch:tm&gt; &lt;list&gt;
## 1 vectoriel   19ms  24.7ms     41.6     11.4MB     9.90    21     5      505ms &lt;int ~
## 2 boucle     239ms 310.3ms      3.22        0B    17.7      2    11      621ms &lt;dbl ~
## # ... with 3 more variables: memory &lt;list&gt;, time &lt;list&gt;, gc &lt;list&gt;</code></pre>
<p>Pour simplifier l’analyse des résultats retournés par <code>mark</code>, je vais utiliser la fonction suivante pour imprimer les sorties produites par cette fonction dans le reste de ces notes.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Impression simplifiée d&#39;une sortie de bench::mark</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Conserve six éléments et imprime sous forme de data frame</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param x sortie produite par bench::mark</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>print_bench_mark <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">inherits</span>(x, <span class="at">what =</span> <span class="st">&quot;bench_mark&quot;</span>)) {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(<span class="st">&quot;&#39;x&#39; n&#39;est pas une sortie de bench::mark&quot;</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">expression =</span> <span class="fu">as.character</span>(x<span class="sc">$</span>expression),</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">n_itr =</span> x<span class="sc">$</span>n_itr,</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">min =</span> <span class="cf">if</span> (<span class="fu">inherits</span>(x<span class="sc">$</span>min, <span class="st">&quot;bench_time&quot;</span>)) <span class="fu">as.character</span>(x<span class="sc">$</span>min) <span class="cf">else</span> x<span class="sc">$</span>min,</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">median =</span> <span class="cf">if</span> (<span class="fu">inherits</span>(x<span class="sc">$</span>min, <span class="st">&quot;bench_time&quot;</span>)) <span class="fu">as.character</span>(x<span class="sc">$</span>median) <span class="cf">else</span> x<span class="sc">$</span>median,</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">mem_alloc =</span> <span class="fu">as.character</span>(x<span class="sc">$</span>mem_alloc),</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">n_gc =</span> x<span class="sc">$</span>n_gc,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(df)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">invisible</span>(df)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(sortie_mark)</span></code></pre></div>
<pre><code>##   expression n_itr   min  median mem_alloc n_gc
## 1  vectoriel    21  19ms  24.7ms    11.4MB    5
## 2     boucle     2 239ms 310.3ms        0B   11</code></pre>
<p>Dans cette sortie, possédant une ligne par expression à profiler, les différentes colonnes contiennent :</p>
<ul>
<li><code>expression</code> : identifiant de l’expression,</li>
<li><code>n_itr</code> : nombre de répétitions (ou itérations) de l’exécution de l’expression,</li>
<li><code>min</code> : temps pris par l’exécution la plus rapide de l’expression,</li>
<li><code>median</code> : temps médian d’exécution parmi les répétitions,</li>
<li><code>mem_alloc</code> : quantité totale de mémoire allouée pendant une exécution de l’expression,</li>
<li><code>n_gc</code> : nombre total de récupérations de mémoire (en anglais <em>garbage collections</em>, d’où l’abréviation <code>gc</code>) effectuées pendant toutes les répétitions d’exécution.</li>
</ul>
<p>Dans cet exemple, la fonction <code>compte_impair_vectoriel</code> est beaucoup plus rapide que la fonction <code>compte_impair_boucle</code> (temps médians de 24.7ms = 0.0247 secondes versus 310.3ms = 0.3103 secondes), mais elle utilise plus de mémoire (11.4MB versus approximativement 0B).</p>
<p>Les unités de temps et de mémoire sont adaptées de façon à ce que les nombres imprimés ne soient pas trop gros, ni trop petits. Ici, la fonction <code>mark</code> a choisi de mesurer le temps en millisecondes (ms).
Nous aurions pu demander à <code>mark</code> d’utiliser des unités de temps aussi petites que des nanosecondes (ns) via son argument <code>time_unit</code>. Remarquez que ces unités peuvent varier d’une expression à l’autre, comme c’est le cas pour les unités de mémoire dans l’exemple.</p>
<p>Par défaut, la fonction <code>mark</code> vérifie si les sorties produites par les différentes expressions sont équivalentes avec la fonction <code>all.equal</code>. Dans l’exemple présenté ici, cette vérification est pertinente. Elle ne l’est cependant pas toujours. Parfois, il est normal que les expressions à comparer ne retournent pas des résultats équivalents (p. ex. pas sous le même format). Dans un tel cas, il faut ajouter l’argument <code>check = FALSE</code> dans l’appel à la fonction <code>mark</code>.</p>
<p>La fonction <code>mark</code> sélectionne de façon automatique le nombre de fois qu’est répétée (ou itérée) l’exécution de chacune des expressions. Nous pouvons aussi contrôler ce nombre de répétitions à l’aide des arguments <code>iterations</code>, <code>min_iterations</code> et <code>max_iterations</code>. Pour nous assurer d’effectuer toujours au moins 10 répétitions, nous utiliserons à l’avenir l’argument <code>min_iterations = 10</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>sortie_mark <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compte_impair_vectoriel</span>(obs), </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compte_impair_boucle</span>(obs),</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(sortie_mark)</span></code></pre></div>
<pre><code>##                     expression n_itr     min  median mem_alloc n_gc
## 1 compte_impair_vectoriel(obs)    18  18.8ms  27.2ms    11.4MB    4
## 2    compte_impair_boucle(obs)    10 187.8ms 214.3ms        0B   68</code></pre>
<p>Le message d’avertissement <code>"Some expressions had a GC in every iteration; so filtering is disabled."</code>, obtenu lors des deux appels précédents à la fonction <code>mark</code> n’est pas problématique. Dans le calcul du temps médian, la fonction <code>mark</code> cherche à considérer seulement les exécutions pendant lesquelles de la récupération de mémoire n’a pas eu lieu, car celle-ci ralentit l’exécution. Elle est contrainte à ne pas effectuer ce filtrage si toutes les exécutions d’une expression ont subi de la récupération de mémoire. La section suivante explique ce qu’est la récupération de mémoire.</p>
<p>Avant de terminer, le package <code>bench</code> offre même une <a href="http://bench.r-lib.org/reference/autoplot.bench_mark.html">méthode pour la fonction générique <code>plot</code></a> permettant de représenter graphiquement les résultats du profilage.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sortie_mark)</span></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2021_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Pour plus d’informations concernant ce graphique et d’autres possibilités du package <code>bench</code>, le lecteur est référé à la documentation du package : <a href="http://bench.r-lib.org/" class="uri">http://bench.r-lib.org/</a>.</p>
</div>
<div id="liens-entre-gestion-de-la-mémoire-et-temps-dexécution" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Liens entre gestion de la mémoire et temps d’exécution</h2>
<p>Il n’est pas rare en R que des solutions soient rapides, mais utilisent beaucoup de mémoire. Comme illustré dans l’exemple précédent, et comme nous l’illustrerons une autre fois plus loin dans ces notes, les calculs matriciels et vectoriels sont souvent des options de calcul optimisés en R. Cependant, ils impliquent la création de matrices ou de vecteurs contenant potentiellement un grand nombre d’éléments. Ainsi, la rapidité a parfois un envers : l’utilisation d’une grande quantité de mémoire. Nous verrons que cette contrepartie peut devenir problématique lors du traitement d’une grande quantité de données. Il faut parfois gérer un compromis entre temps d’exécution et quantité de mémoire utilisée.</p>
<p>Aussi, l’opération d’allouer de l’espace dans la mémoire d’un ordinateur pour stocker des données prend un certain temps à être réalisée. Un programme R qui génère de nombreuses allocations en mémoire aura tendance à être lent. Une des stratégies présentées ici identifie des opérations à éviter en raison du grand nombre d’allocations en mémoire qu’elles provoquent.</p>
<div id="récupération-de-mémoire" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Récupération de mémoire</h3>
<p>Étant donné que les allocations et désallocations de mémoire en R sont réalisées de façon implicite plutôt qu’explicitement par l’utilisateur comme dans certains langages informatiques (p. ex. en C), R doit s’occuper de libérer périodiquement de façon automatique la mémoire qui n’est plus utilisée. Cette opération s’appelle « <a href="https://fr.wikipedia.org/wiki/Ramasse-miettes_(informatique)">récupération de mémoire</a> », en anglais <em>garbage collection</em> ou <em>gc</em>. Il s’agit d’une opération essentielle pour ne pas saturer la mémoire de l’ordinateur pendant une session R.</p>
<p>Tout comme l’allocation de mémoire, la récupération de mémoire prend un peu de temps à être réalisée. Il est donc pertinent de savoir si le récupérateur de mémoire (<em>garbage collector</em>), aussi appelé ramasse-miettes, a été lancé pendant l’exécution d’une expression. Cette opération, dont nous ne contrôlons pas le déclenchement, ralentit légèrement les exécutions.</p>
</div>
</div>
<div id="fonctions-rprof-et-summaryrprof" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Fonctions <code>Rprof</code> et <code>summaryRprof</code></h2>
<p>Les fonctions <code>system.time</code> et <code>mark</code> sont bien pratiques pour évaluer un temps global d’exécution. Cependant, elles ne nous aident pas à identifier les parties d’un programme R, typiquement le corps d’une fonction, qui sont les plus lentes. Pour arriver à identifier les instructions causant des lenteurs, il faut plutôt utiliser un outil telles que les fonctions <a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/Rprof.html"><code>Rprof</code></a> et <a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/summaryRprof.html"><code>summaryRprof</code></a>.</p>
<p>Pour utiliser ces fonctions, il faut ajouter la commande <code>Rprof()</code> avant le bout de code à minuter et ajouter <code>Rprof(NULL)</code> après le bout de code, comme dans cet exemple :</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Rprof</span>(<span class="at">interval =</span> <span class="fl">0.001</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">compte_impair_boucle</span>(obs)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Rprof</span>(<span class="cn">NULL</span>)</span></code></pre></div>
<p>Un fichier a est créé dans notre répertoire de travail. Il se nomme par défaut <code>Rprof.out</code>, mais nous pouvons changer ce nom avec l’argument <code>filename</code> de la fonction <code>Rprof</code>. À chaque 0.001 seconde (argument <code>interval</code>), R a écrit dans ce fichier le nom de la fonction ou des fonctions dont un appel est en cours d’exécution. La fonction <code>Rprof</code> conserve donc une trace de la <a href="https://fr.wikipedia.org/wiki/Pile_d%27ex%C3%A9cution">pile d’exécution</a> (en anglais <em>call stack</em>) à intervalle de temps fixes.</p>
<p>Typiquement, nous n’allons pas voir directement le contenu de ce fichier. Nous en affichons plutôt un résumé avec la fonction <code>summaryRprof</code> comme suit :</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summaryRprof</span>(<span class="st">&quot;Rprof.out&quot;</span>)</span></code></pre></div>
<pre><code>## $by.self
##                        self.time self.pct total.time total.pct
## &quot;compte_impair_boucle&quot;     0.095    52.49      0.181    100.00
## &quot;%%&quot;                       0.086    47.51      0.086     47.51
## 
## $by.total
##                        total.time total.pct self.time self.pct
## &quot;compte_impair_boucle&quot;      0.181    100.00     0.095    52.49
## &quot;%%&quot;                        0.086     47.51     0.086    47.51
## 
## $sample.interval
## [1] 0.001
## 
## $sampling.time
## [1] 0.181</code></pre>
<p>Dans cette sortie, les éléments <code>by.self</code> et <code>by.total</code> contiennent les mêmes valeurs, mais pas dans le même ordre (colonnes interchangées). Les colonnes <code>total.time</code> et <code>total.pct</code> réfèrent au temps total passé à l’exécution de l’appel à une fonction. Pour les colonnes <code>self.time</code> et <code>self.pct</code>, le temps d’exécution des appels de fonctions imbriqués dans l’appel de la fonction en question est retiré du temps total.</p>
<p>Dans l’exemple, la commande <code>compte_impair_boucle(x)</code> prend un total de 0.181 seconde à être évaluée. Exécuter un appel à la fonction <code>compte_impair_boucle</code> signifie exécuter le corps de la fonction avec les valeurs d’arguments fournis en entrée. De l’exécution du corps de la fonction <code>compte_impair_boucle</code>, seul l’appel à l’opérateur <code>%%</code> apparaît dans la sortie de <code>summaryRprof</code>. Les appels aux autres fonctions ou opérateurs sont ici tellement rapides qu’ils n’ont pas été détectés par <code>Rprof</code>. Le temps passé à évaluer les appels à l’opérateur <code>%%</code> est de 0.086 seconde. Ainsi, le <code>self.time</code> de <code>compte_impair_boucle</code> est 0.181 - 0.086 = 0.095 seconde.</p>
<p>Afin de mieux expliquer l’interprétation de la sortie de <code>summaryRprof</code>, voyons aussi un autre exemple qui produit une sortie plus longue. Les arguments <code>memory.profiling</code> et <code>gc.profiling</code> de la fonction <code>Rprof</code> sont illustrés.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Facteur généré aléatoirement pour l&#39;exemple</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>facteur <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">size =</span> <span class="fu">length</span>(obs), <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Profilage du temps d&#39;exécution et de la gestion de la mémoire </span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"># d&#39;un appel à aggregate avec les données simulées</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="fu">Rprof</span>(<span class="at">interval =</span> <span class="fl">0.01</span>, <span class="at">memory.profiling =</span> <span class="cn">TRUE</span>, <span class="at">gc.profiling =</span> <span class="cn">TRUE</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(<span class="at">x =</span> obs, <span class="at">by =</span> <span class="fu">list</span>(facteur), <span class="at">FUN =</span> median)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="fu">Rprof</span>(<span class="cn">NULL</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Résumé de la sortie de Rprof</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="fu">summaryRprof</span>(<span class="st">&quot;Rprof.out&quot;</span>, <span class="at">memory =</span> <span class="st">&quot;both&quot;</span>)</span></code></pre></div>
<pre><code>## $by.self
##                         self.time self.pct total.time total.pct mem.total
## &quot;[.data.frame&quot;               0.07    24.14       0.18     62.07      77.4
## &quot;&lt;GC&gt;&quot;                       0.06    20.69       0.06     20.69      15.3
## &quot;&lt;Anonymous&gt;&quot;                0.04    13.79       0.05     17.24       7.6
## &quot;anyDuplicated.default&quot;      0.03    10.34       0.03     10.34       8.0
## &quot;unique.default&quot;             0.02     6.90       0.07     24.14      23.6
## &quot;match&quot;                      0.01     3.45       0.07     24.14      27.5
## &quot;split.default&quot;              0.01     3.45       0.02      6.90      34.7
## &quot;as.character.factor&quot;        0.01     3.45       0.01      3.45       0.0
## &quot;complete.cases&quot;             0.01     3.45       0.01      3.45       3.9
## &quot;f&quot;                          0.01     3.45       0.01      3.45       0.0
## &quot;factor&quot;                     0.01     3.45       0.01      3.45      23.3
## &quot;is.na&quot;                      0.01     3.45       0.01      3.45       8.5
## 
## $by.total
##                         total.time total.pct mem.total self.time self.pct
## &quot;aggregate&quot;                   0.28     96.55     144.0      0.00     0.00
## &quot;aggregate.data.frame&quot;        0.28     96.55     144.0      0.00     0.00
## &quot;aggregate.default&quot;           0.28     96.55     144.0      0.00     0.00
## &quot;[.data.frame&quot;                0.18     62.07      77.4      0.07    24.14
## &quot;[&quot;                           0.18     62.07      77.4      0.00     0.00
## &quot;unique.default&quot;              0.07     24.14      23.6      0.02     6.90
## &quot;match&quot;                       0.07     24.14      27.5      0.01     3.45
## &quot;sort&quot;                        0.07     24.14      20.3      0.00     0.00
## &quot;&lt;GC&gt;&quot;                        0.06     20.69      15.3      0.06    20.69
## &quot;unique&quot;                      0.06     20.69      11.8      0.00     0.00
## &quot;&lt;Anonymous&gt;&quot;                 0.05     17.24       7.6      0.04    13.79
## &quot;do.call&quot;                     0.05     17.24       7.6      0.00     0.00
## &quot;FUN&quot;                         0.04     13.79      55.1      0.00     0.00
## &quot;lapply&quot;                      0.04     13.79      55.1      0.00     0.00
## &quot;anyDuplicated.default&quot;       0.03     10.34       8.0      0.03    10.34
## &quot;anyDuplicated&quot;               0.03     10.34       8.0      0.00     0.00
## &quot;split.default&quot;               0.02      6.90      34.7      0.01     3.45
## &quot;as.factor&quot;                   0.02      6.90      35.1      0.00     0.00
## &quot;sort.int&quot;                    0.02      6.90      20.3      0.00     0.00
## &quot;split&quot;                       0.02      6.90      34.7      0.00     0.00
## &quot;unname&quot;                      0.02      6.90      34.7      0.00     0.00
## &quot;as.character.factor&quot;         0.01      3.45       0.0      0.01     3.45
## &quot;complete.cases&quot;              0.01      3.45       3.9      0.01     3.45
## &quot;f&quot;                           0.01      3.45       0.0      0.01     3.45
## &quot;factor&quot;                      0.01      3.45      23.3      0.01     3.45
## &quot;is.na&quot;                       0.01      3.45       8.5      0.01     3.45
## &quot;.rs.callAs&quot;                  0.01      3.45       0.0      0.00     0.00
## &quot;as.character&quot;                0.01      3.45       0.0      0.00     0.00
## &quot;doTryCatch&quot;                  0.01      3.45       0.0      0.00     0.00
## &quot;mean&quot;                        0.01      3.45       8.5      0.00     0.00
## &quot;median.default&quot;              0.01      3.45       8.5      0.00     0.00
## &quot;Rprof&quot;                       0.01      3.45       0.0      0.00     0.00
## &quot;sort.default&quot;                0.01      3.45       8.5      0.00     0.00
## &quot;tryCatch&quot;                    0.01      3.45       0.0      0.00     0.00
## &quot;tryCatchList&quot;                0.01      3.45       0.0      0.00     0.00
## &quot;tryCatchOne&quot;                 0.01      3.45       0.0      0.00     0.00
## &quot;withCallingHandlers&quot;         0.01      3.45       0.0      0.00     0.00
## 
## $sample.interval
## [1] 0.01
## 
## $sampling.time
## [1] 0.29</code></pre>
<p>Dans cet exemple, les éléments <code>by.self</code> et <code>by.total</code> ne contiennent pas les mêmes lignes. Les fonctions dont les <code>self.time</code> sont nuls n’apparaissent pas dans l’élément <code>by.self</code>. Nous voyons aussi que les lignes sont ordonnées en ordre décroissant de <code>self.time</code> dans l’élément <code>by.self</code> et en ordre décroissant de <code>total.time</code> dans l’élément <code>by.total</code>.</p>
<p>La colonne <code>mem.total</code> a été ajoutée comparativement à la sortie obtenue dans l’exemple précédent. Elle indique la quantité de mémoire utilisée. Elle est présente en raison de l’argument <code>memory.profiling = TRUE</code>. L’argument <code>gc.profiling = TRUE</code> à quant à lui pour effet de rapporter les temps d’appel au récupérateur de mémoire, identifié par <code>"&lt;GC&gt;"</code>, si celui-ci a été lancé.</p>
<p>Nous constatons que le code de la méthode <code>aggregate.data.frame</code> fait appel à un grand nombre de fonctions. Nous n’analyserons pas cette sortie davantage ici. Mentionnons seulement que les méthodes de la fonction générique <code>aggregate</code> ne sont pas vraiment conçues pour être rapides.</p>
</div>
<div id="package-profvis" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> Package <code>profvis</code></h2>
<p>Pour identifier encore plus facilement les lignes les plus lentes de notre code, nous pouvons utiliser le <a href="https://CRAN.R-project.org/package=profvis">package <code>profvis</code></a>. Ce package offre en fait une façon de visualiser le résultat produit par <code>Rprof</code>. Voici un exemple de son utilisation.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(profvis)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">profvis</span>({</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  compte_impair_boucle <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    k <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (n <span class="cf">in</span> x) {</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (n <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">1</span>){</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>        k <span class="ot">&lt;-</span> k <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>      } </span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    k</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compte_impair_boucle</span>(obs)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>})</span></code></pre></div>
<p>Pour obtenir le détail du temps d’exécution par ligne du corps d’une de nos fonctions, il faut fournir, dans l’appel à la fonction <code>profvis</code>, le code définissant la fonction en plus de l’instruction appelant la fonction. Remarquez les accolades nécessaires lorsque l’expression à profiler s’étend sur plus d’une ligne. Le résultat obtenu est ouvert dans une fenêtre indépendante, dont voici une copie :</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-21"></span>
<img src="fig/profvis.png" alt="Fenêtre de profilage ouverte par l'exemple  d'appel à la fonction profvis précédent" width="100%" />
<p class="caption">
Figure 1.1: Fenêtre de profilage ouverte par l’exemple d’appel à la fonction profvis précédent
</p>
</div>
<p>RStudio intègre particulièrement bien la fenêtre affichant les résultats d’un appel à la fonction <code>profvis</code>. La figure précédente ne montre qu’un des deux onglets de cette fenêtre, soit l’onglet <code>Flame Graph</code>. La fonction <code>profvis</code> profile à la fois l’utilisation de la mémoire (colonne <code>Memory</code>) et du temps d’exécution (colonne <code>Time</code>).</p>
<p>Dans l’exemple, nous voyons encore clairement que ce sont les appels à l’opérateur <code>%%</code> qui prennent le plus de temps à être évalués dans le corps de la fonction <code>compte_impair_boucle</code>.</p>
<p>Le site web suivant documente l’utilisation du package <code>profvis</code> : <a href="http://rstudio.github.io/profvis/" class="uri">http://rstudio.github.io/profvis/</a>.</p>
</div>
</div>
<div id="stratégies-doptimisation-du-temps-dexécution" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Stratégies d’optimisation du temps d’exécution</h1>
<p>Il y a différentes stratégies utiles à connaître pour écrire du code R rapide. Voici une énumération de ces stratégies, qui sont présentées dans les sous-sections suivantes.</p>
<ol style="list-style-type: decimal">
<li>Utiliser des fonctions optimisées.</li>
<li>Faire seulement ce qui est nécessaire.</li>
<li>Exploiter les calculs matriciels et vectoriels.</li>
<li>Éviter les allocations de mémoire inutiles.</li>
<li>Faire du calcul en parallèle.</li>
<li>Reprogrammer en C ou C++ les bouts de code les plus lents.</li>
</ol>
<p>Pour illustrer ces astuces, nous allons souvent utiliser un exemple tiré de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a>. Il s’agit de fonctions R ayant pour but d’estimer la fonction de densité d’une variable aléatoire par la méthode du noyau à partir d’observations de la variable aléatoire. De l’information sur cette méthode, appelée en anglais <em>Kernel density estimation</em>, peut être trouvée sur la page Wikipédia suivante : <a href="https://fr.wikipedia.org/wiki/Estimation_par_noyau" class="uri">https://fr.wikipedia.org/wiki/Estimation_par_noyau</a>.</p>
<p>Il existe en fait déjà une fonction dans le package <code>stats</code> pour faire de l’estimation de densité par noyau : la <a href="https://stat.ethz.ch/R-manual/R-patched/library/stats/html/density.html">fonction <code>density</code></a>, déjà vue dans les <a href="https://stt4230.rbind.io/communication_resultats/graphiques_r/#courbe-destimation-de-densit%C3%A9-%C3%A0-noyau---m%C3%A9thode-plot.density">notes sur les graphiques</a>. Voici un exemple de ce qu’il est possible de réaliser avec cette fonction.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>dens <span class="ot">&lt;-</span> <span class="fu">density</span>(<span class="at">x =</span> faithful<span class="sc">$</span>eruptions)  <span class="co"># faithful provient du package datasets</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> faithful<span class="sc">$</span>eruptions, </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">freq =</span> <span class="cn">FALSE</span>,</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">xlab =</span> <span class="st">&quot;durées des éruptions&quot;</span>,</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">ylab =</span> <span class="st">&quot;densité&quot;</span>,</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">main =</span> <span class="st">&quot;Densité empirique des durées des éruptions du geyser Old Faithful&quot;</span>,</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">cex.main =</span> <span class="fl">0.9</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(dens)</span></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2021_files/figure-html/unnamed-chunk-22-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Un histogramme est aussi une méthode d’estimation de densité. Ici, nous avons superposé une courbe de densité estimée par la méthode du noyau (aussi appelée densité Kernel) à un histogramme.</p>
<p>Nous allons écrire une version moins puissante de la fonction <code>density</code>. L’estimation de densité par noyau au point <span class="math inline">\(x\)</span> se fait par la formule suivante :</p>
<p><span class="math inline">\(\hat{f}(x) = \frac{1}{nh} \sum_{i = 1}^n K \left( \frac{x - x_i}{h} \right)\)</span></p>
<p>où <span class="math inline">\(x_i\)</span> pour <span class="math inline">\(i=1, 2, \ldots, n\)</span> sont les observations, <span class="math inline">\(K\)</span> est une fonction noyau (en anglais <em>kernel</em>) à définir et <span class="math inline">\(h\)</span> est un paramètre de lissage (parfois appelée fenêtre). Plus la valeur de <span class="math inline">\(h\)</span> est grande, plus la courbe obtenue est lisse.</p>
<p>La fonction <code>density</code> permet l’utilisation de plusieurs fonctions noyau via l’argument <code>kernel</code>. Nous allons plutôt nous restreindre au noyau gaussien, qui est en fait la fonction de densité d’une distribution normale standard. Nous allons donc utiliser la fonction <code>dnorm</code> pour évaluer la fonction <span class="math inline">\(K\)</span> dans la formule ci-dessus.</p>
<p>Voici la première fonction proposée.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 1 : utilisation de 2 boucles imbriquées</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param x vecteur numérique contenant les observations</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param xpts vecteur numérique contenant les points en lesquels l&#39;estimation de la </span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39;             densité doit être effectuée</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param h nombre réel &gt; 0 : la valeur du paramètre de lissage</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return vecteur numérique contenant la densité estimée en tous les points de xpts</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>ksmooth_double_loop <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xpts, h) </span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  dens <span class="ot">&lt;-</span> <span class="fu">double</span>(<span class="fu">length</span>(xpts))</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(xpts)) {</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    ksum <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(x)) {</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>      d <span class="ot">&lt;-</span> xpts[i] <span class="sc">-</span> x[j]</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>      ksum <span class="ot">&lt;-</span> ksum <span class="sc">+</span> <span class="fu">dnorm</span>(d <span class="sc">/</span> h)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    dens[i] <span class="ot">&lt;-</span> ksum <span class="sc">/</span> (n <span class="sc">*</span> h)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>  dens</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Dans la fonction <code>ksmooth_double_loop</code>, le premier argument, nommé <code>x</code>, n’est pas équivalent au <span class="math inline">\(x\)</span> de la formule. Le <span class="math inline">\(x\)</span> de la formule représente un point en lequel nous souhaitons faire l’estimation. Son équivalent dans la fonction <code>ksmooth_double_loop</code> est donc un élément du vecteur <code>xpts</code>. Ce sont les <span class="math inline">\(x_i\)</span> de la formule que nous retrouvons dans le vecteur <code>x</code>. Dans la boucle, ce vecteur <code>x</code> est parcouru en utilisant l’indice <code>j</code>. Alors, en fait, <code>x[j]</code> dans le corps de la fonction représente un <span class="math inline">\(x_i\)</span> dans la formule. Le code aurait pu coller davantage à la notation dans la formule pour être encore plus clair, mais j’ai choisi de le conserver tel qu’il a été proposé dans <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a>. Tout ce que j’ai changé ici par rapport à cette référence est le nom de la fonction. J’ai renommé <code>ksmooth_double_loop</code> la fonction que <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a> ont nommé <code>ksmooth1</code>.</p>
<p>Notons que nous pouvons considérer ici que la fonction <code>ksmooth_double_loop</code> a d’abord été testée. Nous supposons donc qu’elle retourne un résultat valide. Voici d’ailleurs ce qu’elle retourne si elle reçoit en entrée dix mille observations générées aléatoirement selon une loi normale standard et que nous lui demandons d’effectuer une estimation de densité en 17 points entre -4 et 4 (la séquence des nombres entre -4 et 4 inclusivement, par bonds de 0.5).</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation des observations</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10000</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Points pour lesquels nous souhaitons estimer la densité</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>xpts <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">length.out =</span> <span class="dv">17</span>)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Résultat obtenu</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>densite_kdl <span class="ot">&lt;-</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Graphique</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> x, </span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">freq =</span> <span class="cn">FALSE</span>, </span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">ylab =</span> <span class="st">&quot;densité&quot;</span>,</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">main =</span> <span class="st">&quot;Densité empirique d&#39;un échantillon aléatoire tiré d&#39;une distribution N(0, 1)&quot;</span>,</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">cex.main =</span> <span class="fl">0.9</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="at">x =</span> xpts, <span class="at">y =</span> densite_kdl)</span></code></pre></div>
<p><img src="/amelioration_code/optim_temps_r_2021_files/figure-html/unnamed-chunk-25-1.png" width="80%" style="display: block; margin: auto;" /></p>
<div id="astuce-1-utiliser-des-fonctions-optimisées" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Astuce 1 : Utiliser des fonctions optimisées</h2>
<p>Lorsque nous devons effectuer une tâche pour laquelle une fonction optimisée en temps de calcul existe déjà, il est préférable d’utiliser cette fonction. R est un logiciel libre. Le partage de code fait partie de la philosophie première du logiciel. Et cette réutilisation peut nous faire économiser beaucoup de temps.</p>
<p>Par exemple, est-ce que la fonction <code>density</code>, provenant du package <code>stats</code>, est plus rapide que la fonction <code>ksmooth_double_loop</code>?</p>
<p>Premièrement, convainquons-nous que les deux fonctions peuvent effectuer le même calcul. Réutilisons les vecteurs <code>x</code> et <code>xpts</code> créés ci-dessus. La commande suivante :</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>densite_kdl <span class="ot">&lt;-</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span></code></pre></div>
<p>lance pratiquement le même calcul que cette commande :</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>densite_d <span class="ot">&lt;-</span> <span class="fu">density</span>(</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> x,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">bw =</span> <span class="dv">1</span>,</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">&quot;gaussian&quot;</span>,</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">n =</span> <span class="dv">17</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Rappelons que <code>xpts</code> avait été défini comme suit :</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>xpts <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">length.out =</span> <span class="dv">17</span>)</span></code></pre></div>
<p>d’où le choix des valeurs fournies aux arguments <code>from</code>, <code>to</code> et <code>n</code> de <code>density</code>.</p>
<p>Comparons maintenant les valeurs obtenues.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_kdl, densite_d<span class="sc">$</span>y)</span></code></pre></div>
<pre><code>## [1] &quot;Mean relative difference: 0.0009604423&quot;</code></pre>
<p>Il y a de très petites différences entre les valeurs, parce que le paramètre de lissage <code>h</code> de <code>ksmooth_double_loop</code> n’est pas tout à fait définit comme le paramètre <code>bw</code> de la fonction <code>density</code>. Cependant, ces différences sont tellement petites que nous pouvons tout de même considérer que les deux fonctions effectuent le même calcul.</p>
<p>Comparons les temps d’exécution des deux fonctions.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ex_astuce_1 <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">ksmooth_double_loop =</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">density =</span> <span class="fu">density</span>(<span class="at">x =</span> x, <span class="at">bw =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">&quot;gaussian&quot;</span>, <span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">n =</span> <span class="dv">17</span>), </span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_astuce_1)</span></code></pre></div>
<pre><code>##            expression n_itr      min   median mem_alloc n_gc
## 1 ksmooth_double_loop    10 187.3237 203.4984      184B   22
## 2             density   725   0.4889   0.5432     315KB    5</code></pre>
<p>La fonction <code>density</code> retourne presque instantanément le résultat, alors que la fonction <code>ksmooth_double_loop</code> doit rouler pendant plusieurs secondes pour effectuer une estimation en 17 points, à partir de 10000 observations.</p>
<p>Le coeur du calcul de la fonction <code>density</code> est effectué par du code en langage C. C’est pour cette raison qu’elle est à ce point plus rapide que la fonction <code>ksmooth_double_loop</code>. Nous allons y revenir à l’astuce 6.</p>
</div>
<div id="astuce-2-faire-seulement-ce-qui-est-nécessaire" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Astuce 2 : Faire seulement ce qui est nécessaire</h2>
<p>L’idée derrière cette astuce est simplement de ne pas alourdir un code d’évaluations inutiles.</p>
<p>Par exemple, si nous voulons calculer la somme des valeurs dans chacune des colonnes d’une matrice, la fonction <code>colSums</code> est plus rapide que la fonction <code>apply</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(<span class="dv">100</span> <span class="sc">*</span> <span class="dv">1000</span>), <span class="at">nrow =</span> <span class="dv">100</span>, <span class="at">ncol =</span> <span class="dv">1000</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>ex_astuce_2 <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colSums</span>(<span class="at">x =</span> mat), </span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">apply</span>(<span class="at">X =</span> mat, <span class="at">MARGIN =</span> <span class="dv">2</span>, <span class="at">FUN =</span> sum),</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;us&quot;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_astuce_2)</span></code></pre></div>
<pre><code>##                              expression n_itr    min median mem_alloc n_gc
## 1                      colSums(x = mat)  6947   63.5   67.5    7.86KB    1
## 2 apply(X = mat, MARGIN = 2, FUN = sum)   161 2361.7 2601.7    2.02MB    9</code></pre>
<p>Ce résultat s’explique par le fait que la fonction <code>colSums</code> est spécialisée dans la tâche que nous cherchions à effectuer. Son code est simplifié, par rapport au code de <code>apply</code> qui peut appliquer n’importe quelle fonction sur n’importe quelle dimension d’un array. Nous pourrions aussi dire que la fonction <code>colSums</code> est une fonction optimisée.</p>
<p>Remarquons que la fonction <code>apply</code> utilise ici beaucoup plus de mémoire que la fonction <code>colSums</code>.</p>
<p>C’est cette astuce, de faire seulement ce qui est nécessaire, qui pousse certains programmeurs R à ne pas utiliser la fonction <code>return</code> pour retourner la sortie de leurs fonctions. L’appel à la fonction <code>return</code> amène une évaluation de plus à effectuer. Dans cette fiche, la fonction <code>return</code> n’a jamais été utilisée pour cette raison. Ne pas utiliser <code>return</code> comporte cependant le désavantage de rendre le code un peu moins clair.</p>
<!-- Retiré, car pas vraiment de gain en temps.

C'est cette astuce, de faire seulement ce qui est nécessaire, qui pousse certains programmeurs R à ne pas utiliser la fonction `return` pour retourner la sortie de leurs fonctions. L'appel à la fonction `return` amène une évaluation de plus à effectuer, sans être nécessaire. Pour faire un test, ajoutons un appel à la fonction `return` à la fin de la fonction `compte_impair_vectoriel`.


```r
compte_impair_vectoriel_return <- function(x) {
  return(sum(x %% 2 == 1))
}
```

Maintenant, comparons les temps d'exécution des fonctions `compte_impair_vectoriel` et `compte_impair_vectoriel_return`.


```r
ex_return <- mark(
  sans_return = compte_impair_vectoriel(x),
  avec_return = compte_impair_vectoriel_return(x),
  min_iterations = 100,
  time_unit = "us"
)
print_bench_mark(ex_return)
```

La fonction `compte_impair_vectoriel_return` est effectivement légèrement plus lente que la fonction `compte_impair_vectoriel`. Mais la différence entre les temps d'exécution médians des deux fonctions est à peine de l'ordre de quelques microsecondes. Alors d'autres programmeurs R préfèrent utiliser `return`, même s'il ralentit très légèrement les fonctions, dans le but d'avoir un code le plus clair possible.

-->
</div>
<div id="astuce-3-exploiter-les-calculs-matriciels-et-vectoriels" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Astuce 3 : Exploiter les calculs matriciels et vectoriels</h2>
<p>Nous avons déjà vu qu’en effectuant des calculs matriciels et vectoriels en R, comme avec la fonction <code>compte_impair_vectoriel</code>, nous arrivons à faire un calcul beaucoup plus rapidement qu’avec une boucle, comme avec la fonction <code>compte_impair_boucle</code>. Le calcul matriciel ou vectoriel en R est optimisé pour être très rapide. En fait, ces types de calculs font intervenir des boucles, mais programmées et compilées dans un langage informatique de plus bas niveau (et donc plus rapide) que R tel que le langage C ou Fortran.</p>
<p>Pour illustrer une fois de plus cette astuce, étudions la performance d’une autre fonction d’estimation de densité par noyau gaussien tirée de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw (2002)</a> : la fonction <code>ksmooth2</code>, ici renommée <code>ksmooth_outer</code>. Le corps de cette fonction ne contient aucune boucle. Il fait plutôt du calcul vectoriel en utilisant, notamment, la fonction <code>outer</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit ksmooth_double_loop title params return</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 2 : utilisation de calcul vectoriel seulement</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>ksmooth_outer <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xpts, h) </span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">outer</span>(x, xpts, <span class="st">&quot;-&quot;</span>)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  K <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(D <span class="sc">/</span> h)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  dens <span class="ot">&lt;-</span> <span class="fu">colSums</span>(K) <span class="sc">/</span> (h <span class="sc">*</span> n)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nous aurions aussi pu coder la fonction <code>ksmooth</code> ainsi.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit ksmooth_double_loop title params return</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 3 : utilisation d&#39;une boucle et d&#39;un calcul vectoriel</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>ksmooth_loop <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xpts, h) </span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>  dens <span class="ot">&lt;-</span> <span class="fu">double</span>(<span class="fu">length</span>(xpts))</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(xpts)) {</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    dens[i] <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">dnorm</span>((xpts[i] <span class="sc">-</span> x)<span class="sc">/</span>h)) <span class="sc">/</span> (n <span class="sc">*</span> h)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>  dens</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Cette version remplace la deuxième boucle par un calcul vectoriel, mais conserve la première boucle de <code>ksmooth_double_loop</code>.</p>
<p>Nous aurions même pu procéder comme suit.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit ksmooth_double_loop title params return</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 4 : utilisation d&#39;une fonction de la</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39;              famille des apply et d&#39;un calcul vectoriel</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>ksmooth_apply <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xpts, h) </span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sapply</span>(</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">X =</span> xpts,</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">FUN =</span> <span class="cf">function</span>(xpts_i) {</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sum</span>(<span class="fu">dnorm</span>((xpts_i <span class="sc">-</span> x) <span class="sc">/</span> h)) <span class="sc">/</span> (n <span class="sc">*</span> h)</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Cette version remplace la seule boucle restante par l’utilisation d’une fonction de la famille des <code>apply</code>.</p>
<p>Ces trois versions effectuent bien le même calcul que <code>ksmooth_double_loop</code>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>densite_kdl <span class="ot">&lt;-</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>densite_ko <span class="ot">&lt;-</span> <span class="fu">ksmooth_outer</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>densite_kl <span class="ot">&lt;-</span> <span class="fu">ksmooth_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>densite_ka <span class="ot">&lt;-</span> <span class="fu">ksmooth_apply</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_kdl, densite_ko)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_kdl, densite_kl)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_kdl, densite_ka)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Comparons maintenant les temps d’exécution des quatre versions de <code>ksmooth</code> écrites jusqu’à maintenant.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>ex_astuce_3 <span class="ot">&lt;-</span> <span class="fu">mark</span>(<span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>,</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">v1_double_boucle =</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>), </span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">v2_calcul_vectoriel_seulement =</span> <span class="fu">ksmooth_outer</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">v3_boucle_et_calcul_vectoriel =</span> <span class="fu">ksmooth_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>   <span class="at">v4_apply_et_calcul_vectoriel =</span> <span class="fu">ksmooth_apply</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_astuce_3)</span></code></pre></div>
<pre><code>##                      expression n_itr      min   median mem_alloc n_gc
## 1              v1_double_boucle    10 175.8289 186.5701      184B   23
## 2 v2_calcul_vectoriel_seulement    35  13.0143  13.5004    6.51MB    5
## 3 v3_boucle_et_calcul_vectoriel    39  12.5244  12.6730     2.6MB    3
## 4  v4_apply_et_calcul_vectoriel    39  12.5518  12.7757    2.63MB    2</code></pre>
<p>Nous constatons que les deux dernières versions sont légèrement plus rapides que la version 2 utilisant seulement du calcul vectoriel!</p>
<p>Ce qu’il faut retenir de ces exemples est ceci :</p>
<ul>
<li><p><strong>Le code le plus rapide n’est pas toujours celui que nous croyons</strong>. Il est parfois difficile de prédire quel bout de code sera le plus rapide. Ici, nous aurions pu croire que le calcul totalement vectoriel (<code>ksmooth_outer</code>) serait plus rapide qu’une boucle jumelée à un calcul vectoriel (<code>ksmooth_loop</code>). Pourtant, <code>ksmooth_loop</code> est légèrement plus rapide que <code>ksmooth_outer</code>. Il est donc toujours recommandé, lors de l’optimisation du temps d’exécution d’une fonction, d’essayer les différentes solutions possibles et de mesurer leurs temps d’exécution.</p></li>
<li><p><strong>Les fonctions de la famille des <code>apply</code> ne sont pas nécessairement plus rapides qu’une boucle</strong>. Ces fonctions cachent littéralement des boucles et ne représentent pas une sorte de calcul vectoriel. Leur utilisation est recommandée principalement parce qu’elles mènent à du code plus court et plus clair selon plusieurs programmeurs R, pas à du code nécessairement plus rapide.</p></li>
</ul>
<div id="remarque-concernant-lutilisation-de-la-mémoire" class="section level4 unnumbered">
<h4>Remarque concernant l’utilisation de la mémoire</h4>
<p></p>
<p>La fonction <code>ksmooth_outer</code> est environ 14 fois plus rapide que la fonction <code>ksmooth_double_loop</code>. Cependant, elle utilise beaucoup plus de mémoire ( 6.51MB versus 184B). Une matrice de dimension <code>length(x)</code> par <code>length(xpts)</code> est créée par la fonction. R impose une limite sur la taille des objets créés (pour plus de détails voir la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/Memory-limits.html">fiche d’aide <code>help("Memory-limits")</code></a>). Ainsi, la fonction <code>ksmooth_outer</code> retourne une erreur sur mon ordinateur si je lui donne en entrée des arguments <code>x</code> et <code>xpts</code> trop grands, par exemple :</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>x_test <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1000000</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>xpts_test <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">length.out =</span> <span class="dv">1000000</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>test_memoire <span class="ot">&lt;-</span> <span class="fu">ksmooth_outer</span>(<span class="at">x =</span> x_test, <span class="at">xpts =</span> xpts_test, <span class="at">h =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Error: cannot allocate vector of size 7450.6 Gb</code></pre>
<p>alors que la fonction <code>ksmooth_double_loop</code> est capable de traiter ces vecteurs.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention : ne pas rouler, long à exécuter</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>test_memoire <span class="ot">&lt;-</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x_test, <span class="at">xpts =</span> xpts_test, <span class="at">h =</span> <span class="dv">1</span>)</span></code></pre></div>
<p>C’est un bon exemple de compromis à gérer entre le temps d’exécution et la quantité de mémoire utilisée pour faire des calculs. Un programme peut être très rapide, mais créer un objet potentiellement de taille trop grande pour être stocké en mémoire. Étant donné que notre priorité est un code fonctionnel, il faut s’assurer de ne pas aller au-delà des limites de la mémoire de notre ordinateur. Alors, dans l’optimisation du temps d’exécution, il ne faut pas oublier de garder le contrôle sur la taille des objets créés par notre programme.</p>
</div>
</div>
<div id="astuce-4-éviter-les-allocations-de-mémoire-inutiles" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Astuce 4 : Éviter les allocations de mémoire inutiles</h2>
<p>Allouer de l’espace dans la mémoire d’un ordinateur est une opération coûteuse en temps. Deux opérations plutôt anodines sont à éviter dans une boucle R, car elles provoquent une ou des allocations en mémoire à chaque itération et ralentissent donc beaucoup la boucle. Il s’agit de :</p>
<ol style="list-style-type: decimal">
<li>l’utilisation d’un objet de dimension croissante,</li>
<li>l’assignation de valeur(s) à un ou des éléments d’un data frame.</li>
</ol>
<div id="objets-de-dimension-croissante" class="section level3" number="2.4.1">
<h3><span class="header-section-number">2.4.1</span> Objets de dimension croissante</h3>
<p>Un objet de dimension croissante est, par exemple, une matrice à laquelle nous ajoutons, à chaque itération d’une boucle, une ligne avec <code>rbind</code> ou une colonne avec <code>cbind</code>, comme le fait l’instruction suivante :</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>matrice <span class="ot">&lt;-</span> <span class="fu">rbind</span>(matrice, nouvelle_ligne)</span></code></pre></div>
<p>Avec un vecteur, une instruction similaire ferait plutôt appel à la fonction <code>c</code> ou <code>append</code> comme suit :</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>vecteur <span class="ot">&lt;-</span> <span class="fu">c</span>(vecteur, nouvel_element)</span></code></pre></div>
<p>Le problème avec ces assignations est qu’elles modifient la dimension d’un objet. L’objet ne requiert donc plus la même quantité d’espace mémoire. Il ne serait pas une bonne idée de simplement utiliser les cases mémoires adjacentes pour agrandir l’objet, car ces cases mémoires sont potentiellement utilisées pour stocker d’autres objets R ou n’importe quelle valeur nécessaire à un processus en cours d’exécution sur l’ordinateur. L’ordinateur doit plutôt complètement déplacer l’objet dans de nouvelles cases mémoire qu’il sait être inutilisées afin de ne pas entrer en conflit avec quoi que ce soit. Ainsi, avec les commandes précédentes, nous avons peut-être l’impression de modifier le contenu de certaines cases mémoire alors qu’en réalité nous provoquons une nouvelle allocation de mémoire.</p>
<p><strong>Exemple</strong> :</p>
<p>Simulons une expérience aléatoire dans laquelle nous lançons un dé et additionnons les valeurs obtenues. L’expérience s’arrête lorsqu’une certaine somme cumulative des résultats a été atteinte.</p>
<p>La première fonction que nous allons créer pour simuler cette expérience va utiliser un objet de dimension croissante pour garder une trace des résultats.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version utilisant un vecteur de taille croissante pour stocker les résultats</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return vecteur des résultats de tous les lancers de dé</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>somme_de_vecteur_croissant <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">somme_visee =</span> <span class="dv">50000</span>){</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  somme <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  resultats <span class="ot">&lt;-</span> <span class="fu">integer</span>(<span class="at">length =</span> <span class="dv">0</span>)  <span class="co"># ou resultats &lt;- NULL</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (somme <span class="sc">&lt;</span> somme_visee) {</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    tirage <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    somme <span class="ot">&lt;-</span> somme <span class="sc">+</span> tirage</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    resultats <span class="ot">&lt;-</span> <span class="fu">c</span>(resultats, tirage)</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  resultats</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>La deuxième fonction que nous allons créer pour simuler cette expérience va plutôt utiliser un grand objet de taille fixe pour stocker les résultats.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit somme_de_vecteur_croissant title params return</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version utilisant un vecteur de taille fixe pour stocker les résultats</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>somme_de_vecteur_fixe <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">somme_visee =</span> <span class="dv">50000</span>){</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  somme <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  resultats <span class="ot">&lt;-</span> <span class="fu">integer</span>(somme_visee)</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(somme <span class="sc">&lt;</span> somme_visee) {</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    tirage <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    somme <span class="ot">&lt;-</span> somme <span class="sc">+</span> tirage</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    resultats[i] <span class="ot">&lt;-</span> tirage</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>  resultats[<span class="dv">1</span><span class="sc">:</span>i]</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nous ne savons pas d’avance combien de lancers de dé devront être effectués pour atteindre une somme de <code>somme_visee</code>, mais nous savons que ce sera au maximum <code>somme_visee</code> lancers, puisque le plus petit résultat du lancer d’un dé est 1. Ainsi, nous créons d’abord un très grand vecteur, de longueur <code>somme_visee</code>, et nous allons modifier les éléments de ce vecteur à chaque itération de la boucle (une itération = un lancer de dé). Nous modifions d’abord le premier élément puis le deuxième et ainsi de suite, grâce à l’indicateur de position <code>i</code> que nous incrémentons de 1 à chaque itération. À la fin, nous retournons seulement les éléments du vecteur de résultat qui ont été modifiés.</p>
<p>Comparons les temps d’exécution des deux fonctions pour l’atteinte d’une somme de 50000.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>ex_dim_crois <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">somme_de_vecteur_croissant</span>(), </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">somme_de_vecteur_fixe</span>(),</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_dim_crois)</span></code></pre></div>
<pre><code>##                     expression n_itr      min    median mem_alloc n_gc
## 1 somme_de_vecteur_croissant()    10 254.5291 336.39325     418MB  142
## 2      somme_de_vecteur_fixe()    10  65.0324  70.59515      35MB    8</code></pre>
<p>Nous constatons donc qu’en termes de temps de calcul, et même en termes de quantité de mémoire utilisée, il est ici préférable de créer un très grand objet, de le remplir, puis de mettre de côté les éléments inutilisés que de faire croître la taille d’un objet. C’est de la préallocation de mémoire. Par contre, encore là, il y a une limite à la grandeur de l’objet qui peut être créé.</p>
</div>
<div id="modification-déléments-dans-un-data-frame" class="section level3" number="2.4.2">
<h3><span class="header-section-number">2.4.2</span> Modification d’éléments dans un data frame</h3>
<p>Lorsque nous modifions les éléments d’un objet R dans une boucle, comme nous avons fait dans la fonction <code>somme_de_vecteur_fixe</code> par l’instruction suivante :</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>resultats[i] <span class="ot">&lt;-</span> tirage</span></code></pre></div>
<p>la modification s’effectue sans réallocation de mémoire à chaque itération si :</p>
<ul>
<li>l’objet en question est un objet atomique (vecteur, matrice ou array) ou une liste;</li>
<li>la valeur assignée est du même type que les éléments de l’objet initialisé (dans le cas d’un objet atomique);</li>
<li>l’objet possède au moins autant d’éléments que le nombre d’itérations effectuées.</li>
</ul>
<p>Pour nous en convaincre, faisons quelques tests en utilisant la <a href="https://stat.ethz.ch/R-manual/R-patched/library/base/html/tracemem.html">fonction <code>tracemem</code></a> qui affiche un message à chaque fois qu’un objet est copié en mémoire.</p>
<p>Voici une boucle qui modifie les éléments d’une matrice.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>matrice <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA_integer_</span>, <span class="at">nrow =</span> <span class="dv">4</span>, <span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tracemem</span>(matrice)</span></code></pre></div>
<pre><code>[1] &quot;&lt;0000000019C9B820&gt;&quot;</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>){</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  matrice[, i] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>tracemem[0x0000000019c9b820 -&gt; 0x0000000019f53170]: </code></pre>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">untracemem</span>(matrice)</span></code></pre></div>
<p>L’objet <code>matrice</code> est copié une seule fois, au début de la boucle, mais pas à chaque itération.</p>
<p>Nous observons le même comportement avec une liste.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>liste <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">&quot;list&quot;</span>, <span class="at">length =</span> <span class="dv">5</span>)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tracemem</span>(liste)</span></code></pre></div>
<pre><code>[1] &quot;&lt;000000001A2DC048&gt;&quot;</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>){</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  liste[[i]] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>tracemem[0x000000001a2dc048 -&gt; 0x0000000019d88738]: </code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">untracemem</span>(liste)</span></code></pre></div>
<p>Cependant, R se comporte différemment lors de la modification d’un élément dans un data frame</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">matrix</span>(<span class="cn">NA_integer_</span>, <span class="at">nrow =</span> <span class="dv">4</span>, <span class="at">ncol =</span> <span class="dv">5</span>))</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tracemem</span>(df)</span></code></pre></div>
<pre><code>[1] &quot;&lt;00000176DC803D98&gt;&quot;</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>){</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  df[, i] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>tracemem[0x00000176dc803d98 -&gt; 0x00000176dc193028]: 
tracemem[0x00000176dc193028 -&gt; 0x00000176dc193178]: [&lt;-.data.frame [&lt;- 
tracemem[0x00000176dc193178 -&gt; 0x00000176dc1932c8]: [&lt;-.data.frame [&lt;- 
tracemem[0x00000176dc1932c8 -&gt; 0x00000176dc193418]: [&lt;-.data.frame [&lt;- 
tracemem[0x00000176dc193418 -&gt; 0x00000176dc193568]: [&lt;-.data.frame [&lt;- 
tracemem[0x00000176dc193568 -&gt; 0x00000176dc1936b8]: [&lt;-.data.frame [&lt;- </code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">untracemem</span>(df)</span></code></pre></div>
<p>L’objet <code>df</code> est copié au début de la boucle, puis il est recopié une fois à chaque itération. Ces allocations de mémoire répétées prennent du temps.</p>
<p>La lenteur des opérations de manipulation de data frame est bien connue en R. Des alternatives plus rapides existent, notamment les data tables offerts par le <a href="https://CRAN.R-project.org/package=data.table">package <code>data.table</code></a>. Ce package a été mentionné à quelques reprises dans ce cours, notamment dans les notes sur le <a href="https://stt4230.rbind.io/manipulation_donnees/pretraitement_donnees_r/">prétraitement de données en R</a>. Certaines fonctions de ce package permettent la modification de data table « par référence », donc sans créer de copies de l’objet et nécessiter des allocations de mémoire.</p>
<p>Reprenons l’exemple de la simulation d’une expérience aléatoire de lancers d’un dé jusqu’à l’atteinte d’une certaine somme cumulative des valeurs obtenues. Voici deux autres fonctions réalisant cette expérience, qui diffèrent seulement par le type de l’objet utilisé pour stocker les résultats. La fonction <code>somme_de_data_frame</code> utilise un data frame, la fonction <code>somme_de_matrice</code> une matrice et la fonction <code>somme_de_data_table</code> un data table.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Simulation de lancers d&#39;un dé pour atteindre une somme visée</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version utilisant un data frame pour stocker les résultats</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @param somme_visee somme cumulative de valeurs obtenues à atteindre (par défaut 50000)</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return data frame possédant une ligne par lancer, contenant le numéro de lancer</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>somme_de_data_frame <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">somme_visee =</span> <span class="dv">50000</span>){</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  resultats <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">matrix</span>(<span class="cn">NA_integer_</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> somme_visee))</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>  resultats[, <span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>somme_visee  <span class="co"># Colonne 1 = numéro de l&#39;itération</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>  somme <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (somme <span class="sc">&lt;</span> somme_visee) {</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    tirage <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>    somme <span class="ot">&lt;-</span> somme <span class="sc">+</span> tirage</span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    resultats[i, <span class="dv">2</span>] <span class="ot">&lt;-</span> tirage  <span class="co"># Colonne 2 = résultat obtenu au lancer du dé</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>  resultats[<span class="dv">1</span><span class="sc">:</span>i, ]</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit somme_de_data_frame title params</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version utilisant une matrice pour stocker les résultats</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return matrice possédant une ligne par lancer, contenant le numéro de lancer</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>somme_de_matrice <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">somme_visee =</span> <span class="dv">50000</span>){</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>  resultats <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA_integer_</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> somme_visee)</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  resultats[, <span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>somme_visee  <span class="co"># Colonne 1 = numéro de l&#39;itération</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  somme <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (somme <span class="sc">&lt;</span> somme_visee) {</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    tirage <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    somme <span class="ot">&lt;-</span> somme <span class="sc">+</span> tirage</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>    resultats[i, <span class="dv">2</span>] <span class="ot">&lt;-</span> tirage  <span class="co"># Colonne 2 = résultat obtenu au lancer du dé</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>  resultats[<span class="dv">1</span><span class="sc">:</span>i, ]</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit somme_de_data_frame title params</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version utilisant un data table pour stocker les résultats</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @return data table possédant une ligne par lancer, contenant le numéro de lancer</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39;         dans la première colonne et le résultat obtenu dans la deuxième colonne</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>somme_de_data_table <span class="ot">&lt;-</span> <span class="cf">function</span>(<span class="at">somme_visee =</span> <span class="dv">50000</span>){</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  resultats <span class="ot">&lt;-</span> data.table<span class="sc">::</span><span class="fu">as.data.table</span>(<span class="fu">matrix</span>(<span class="cn">NA_integer_</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> somme_visee))</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  data.table<span class="sc">::</span><span class="fu">set</span>(resultats, <span class="at">j =</span> 1L, <span class="at">value =</span> <span class="dv">1</span><span class="sc">:</span>somme_visee)</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  somme <span class="ot">&lt;-</span> 0L</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> 0L</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (somme <span class="sc">&lt;</span> somme_visee) {</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    tirage <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    somme <span class="ot">&lt;-</span> somme <span class="sc">+</span> tirage</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    i <span class="ot">&lt;-</span> i <span class="sc">+</span> 1L</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    data.table<span class="sc">::</span><span class="fu">set</span>(resultats, <span class="at">i =</span> i, <span class="at">j =</span> 2L, <span class="at">value =</span> tirage)</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>  resultats[<span class="dv">1</span><span class="sc">:</span>i, ]</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Dans la fonction <code>somme_de_data_table</code>, nous avons pris soin de modifier le data table par référence en utilisant la <a href="https://rdatatable.gitlab.io/data.table/reference/assign.html">fonction <code>set</code></a> du package <code>data.table</code>.</p>
<p>Quelle fonction est la plus rapide?</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>ex_compar_df <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">somme_de_data_frame</span>(),</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">somme_de_matrice</span>(),</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">somme_de_data_table</span>(),</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_compar_df)</span></code></pre></div>
<pre><code>##              expression n_itr      min    median mem_alloc n_gc
## 1 somme_de_data_frame()    10 767.9073 840.09420    2.69GB  473
## 2    somme_de_matrice()    10  59.8008  65.13605    35.5MB    8
## 3 somme_de_data_table()    10 189.3442 198.42650   39.78MB   25</code></pre>
<p>Ici, l’utilisation du data frame est environ 13 fois plus lente que l’utilisation d’une matrice (et utilise plus de mémoire)! L’utilisation d’un data table est un peu plus lente que l’utilisation d’une matrice, mais le data table a l’avantage de pouvoir stocker des données de types différents entre ses colonnes.</p>
<p>Le message à retenir ici est, qu’autant que possible, il vaut mieux <strong>éviter d’utiliser un data frame pour stocker des résultats générés dans une boucle</strong>.</p>
<!---
## Astuce 6\ :  Utiliser de la compilation en bytecode

La compilation en bytecode (en anglais *byte code compilation*) consiste en une étape de compilation intermédiaire entre les instructions-machine et le code source. En R, le package `compiler` permet de faire facilement de la compilation en bytecode. Ce package vient avec l'installation de base de R (il est donc déjà installé pour vous, comme le package `parallel`).

En fait, depuis la version 3.4.0 de R, de la compilation bytecode est réalisée par défaut, dès que possible, sans que l'utilisateur ait à appeler lui-même une fonction du package `compiler`. Pour illustrer les gains apportés par la compilation en bytecode, commençons par demander à R de ne pas en réaliser par défaut avec la commande suivante.


```r
library(compiler)
enableJIT(0)
```

Retournons à l'exemple des fonctions `ksmooth` pour estimer une densité par la méthode du noyau pour illustrer la compilation bytecode. Nous allons créé des versions «\ bytecode compilées\ » de notre fonction originale, `ksmooth_double_loop`, et de notre fonction la plus rapide `ksmooth_loop`. 


```r
ksmooth_double_loop_byte <- cmpfun(ksmooth_double_loop)
ksmooth_loop_byte <- cmpfun(ksmooth_loop)
```

Maintenant, comparons les temps d'exécution de ces fonctions avec leurs versions non «\ bytecode compilées\ ».


```r
microbenchmark(unit = "ms",
       dens_ksmooth_double_loop = ksmooth_double_loop(x = x, xpts = xpts, h = 1), 
  dens_ksmooth_double_loop_byte = ksmooth_double_loop_byte(x = x, xpts = xpts, h = 1),
       dens_ksmooth_loop = ksmooth_loop(x = x, xpts = xpts, h = 1),
  dens_ksmooth_loop_byte = ksmooth_loop_byte(x = x, xpts = xpts, h = 1))
```

Bon, cette technique n'est pas magique, mais c'est mieux que rien. Avec à peu près aucun effort de programmation (seul un appel à fonction `cmpfun` a été nécessaire), nous avons réduit de moitié le temps d'exécution de la double boucle dans `ksmooth_double_loop`. Par contre, avec du calcul vectoriel, cette technique n'apporte pas toujours de gain en temps d'exécution, comme nous pouvons le constater avec la fonction `ksmooth_loop`.

Le R core team cherche toujours à rendre R le plus rapide possible. Effectuer de la compilation bytecode par défaut est un exemple de modification du logiciel qui l'a rendu plus rapide. Redonnons à R son comportement par défaut avec la commande suivante.


```r
enableJIT(3)
```

--->
</div>
</div>
<div id="astuce-5-faire-du-calcul-en-parallèle" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Astuce 5 : Faire du calcul en parallèle</h2>
<p>Une importante technique pour réaliser des calculs informatiques plus rapidement est le calcul en parallèle. Il s’agit d’un type de calcul qui, dans sa version la plus simple,</p>
<ul>
<li>brise un long calcul en petits blocs de calcul indépendants;</li>
<li>réalise ces blocs de calcul sur plusieurs unités de calcul, simultanément (donc en parallèle);</li>
<li>rassemble à la fin tous les résultats.</li>
</ul>
<p>Les unités de calcul utilisées peuvent être localisées sur CPU (pour <em>Central Processing Unit</em>) ou sur GPU (pour <em>Graphical Processing Unit</em>). Nous pouvons exploiter différentes unités sur une seule machine ou encore sur plusieurs noeuds de calcul dans une grappe de serveurs.</p>
<p>Je vais réaliser un exemple dans lequel je vais exploiter tous les coeurs du CPU de mon ordinateur.</p>
<p>Il existe un très grand nombre de packages R pour réaliser du calcul en parallèle (<a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html" class="uri">https://cran.r-project.org/web/views/HighPerformanceComputing.html</a>). Un de ces packages vient avec l’installation de R. Il s’agit du package <code>parallel</code>. Ce package est donc déjà installé sur votre ordinateur si R y est installé. Cependant, le package n’est pas chargé par défaut lors de l’ouverture d’une nouvelle session R. Chargeons-le.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(parallel)</span></code></pre></div>
<p>Tout d’abord, voyons combien de coeurs compte mon ordinateur.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">detectCores</span>()</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p>Il compte 4 coeurs logiques.</p>
<p>Maintenant, si nous travaillons sous Windows, il faut d’abord établir une connexion entre R est les différents coeurs avec la fonction <code>makeCluster</code>.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>coeurs <span class="ot">&lt;-</span> <span class="fu">detectCores</span>()</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>grappe <span class="ot">&lt;-</span> <span class="fu">makeCluster</span>(coeurs <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>grappe</span></code></pre></div>
<pre><code>## socket cluster with 3 nodes on host &#39;localhost&#39;</code></pre>
<p>Notons que la première fois que j’ai soumis cette commande, Windows m’a demandé une autorisation.</p>
<p>Remarquons aussi que je n’ai utilisé que 3 des 4 coeurs disponibles sur mon ordinateur dans le but de laisser un coeur libre pour les autres processus actifs.</p>
<p>Ensuite, je vais comparer la fonction <code>ksmooth_apply</code>, qui utilise <code>sapply</code>, à une autre version de <code>ksmooth</code> qui utilise la version parallèle du <code>sapply</code> offerte par le package <code>parallel</code>, nommée <code>parSapply</code>.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit ksmooth_double_loop title params return</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 5 : utilisation de parSapply et d&#39;un calcul vectoriel</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>ksmooth_parallel <span class="ot">&lt;-</span> <span class="cf">function</span>(grappe, x, xpts, h)</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">parSapply</span>(</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">cl =</span> grappe,</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">X =</span> xpts,</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">FUN =</span> <span class="cf">function</span>(xpts_i) {</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sum</span>(<span class="fu">dnorm</span>((xpts_i <span class="sc">-</span> x) <span class="sc">/</span> h)) <span class="sc">/</span> (n <span class="sc">*</span> h)</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Ces fonctions effectuent bien le même calcul.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>densite_ka <span class="ot">&lt;-</span> <span class="fu">ksmooth_apply</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>densite_kp <span class="ot">&lt;-</span> <span class="fu">ksmooth_parallel</span>(<span class="at">grappe =</span> grappe, <span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_ka, densite_kp)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Laquelle est la plus rapide?</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>ex_astuce_5 <span class="ot">&lt;-</span> <span class="fu">mark</span>(<span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>,</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">v4_sapply =</span> <span class="fu">ksmooth_apply</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>), </span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">v5_parSapply =</span> <span class="fu">ksmooth_parallel</span>(<span class="at">grappe =</span> grappe, <span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_astuce_5)</span></code></pre></div>
<pre><code>##     expression n_itr     min   median mem_alloc n_gc
## 1    v4_sapply    38 12.5410 12.70390     2.6MB    1
## 2 v5_parSapply    64  7.1775  7.62145   121.5KB    0</code></pre>
<p>Le calcul en parallèle a permis de réduire un peu le temps d’exécution. Même si 3 coeurs ont été exploités, le calcul n’est pas 3 fois plus rapide, car :</p>
<ul>
<li>mon ordinateur possède en fait 2 coeurs physiques, chacun séparé en 2 coeurs logiques (pour un total de 4 coeurs logiques), et des coeurs logiques ne sont pas aussi rapides que des coeurs physiques;</li>
<li>toutes les communications entre les coeurs et R requièrent aussi un peu de temps.</li>
</ul>
<p>Une fois le calcul terminé, il est recommandé de fermer les connexions entre R et les coeurs de calcul avec la fonction <code>stopCluster</code>.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="fu">stopCluster</span>(grappe)</span></code></pre></div>
<p>Nous aurions pu aller chercher une amélioration plus importante du temps de calcul en utilisant plus d’unités de calcul. Le département de mathématiques et de statistique possède une grappe de calcul pouvant être utilisée par les étudiants du département pour faire du calcul en parallèle. <a href="http://www.calculquebec.ca/fr/">Calcul Québec</a> gère aussi des supercalculateurs pour le calcul en parallèle utilisable gratuitement par tout chercheur (et ses étudiants) admissible aux subventions provenant des conseils de recherche canadiens, à la condition d’avoir obtenu des accès aux ressources : <a href="https://www.calculquebec.ca/services-aux-chercheurs/infrastructures-et-services/" class="uri">https://www.calculquebec.ca/services-aux-chercheurs/infrastructures-et-services/</a>. Finalement, plusieurs plateformes de <a href="https://fr.wikipedia.org/wiki/Cloud_computing"><em>cloud computing</em></a> permettent d’utiliser des serveurs de calculs à faible coût (par exemple <a href="https://aws.amazon.com">Amazon Web Services</a>, <a href="https://azure.microsoft.com">Microsoft Azure</a>, <a href="https://cloud.google.com/">Google Cloud Platform</a>).</p>
<p>Lancer des calculs en parallèle sur une grappe de calcul ne s’effectue pas tout à fait comme le lancement de calculs en parallèle sur une seule machine. La communication avec la grappe s’effectue typiquement via des protocoles SSH et les programmes R se lancent en mode batch grâce à la commande <code>Rscript</code>. Ce sujet ne sera pas couvert ici, car il est plutôt complexe et la mise en oeuvre de calculs en parallèle dépend des ressources à notre disposition. Pour plus d’informations, je vous réfère à un document que j’ai écrit sur le sujet, qui est disponible ici : <a href="https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/" class="uri">https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/</a>.</p>
</div>
<div id="astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</h2>
<p><em>Note : La matière présentée dans cette section ne sera pas évaluée.</em></p>
<p>Une dernière astuce pour rendre du code R plus rapide est de reprogrammer ses bouts les plus lents en C ou C++. Le langage R étant un langage interprété, il n’est pas aussi rapide que du C ou du C++, qui sont des langages de plus bas niveau, plus près du langage machine.</p>
<p>Nous n’utilisons pas cette astuce pour réaliser des analyses de données plus rapidement, mais plutôt pour créer une fonction qui réalise rapidement un certain calcul.</p>
<p>Il existe quelques outils pour intégrer du code C ou C++ en R. Un outil très populaire pour intégrer du code C++ en R est le package <code>Rcpp</code> (<a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a>). Le R de base offre pour sa part les fonctions <code>.C</code>, <code>.Call</code> et <code>.External</code> pour ce faire (voir le manuel <a href="http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces"><em>Writing R Extensions</em>, chapitre 5)</a>. Je vais me contenter ici d’illustrer l’utilisation de la fonction <code>.C</code>, qui est la méthode la plus simple, mais la moins puissante.</p>
<p>La fonction <code>ksmooth_double_loop</code> peut être reprogrammée en C comme suit (<a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw, 2002</a>) :</p>
<pre><code>#include &lt;R.h&gt;
#include &lt;Rmath.h&gt;

void kernel_smooth(double *x, int *n, double *xpts,
       int *nxpts, double *h, double *result)
{
 int i, j;
 double d, ksum;

 for(i=0; i &lt; *nxpts; i++) 
 {
  ksum = 0;
  for(j=0; j &lt; *n; j++) 
  {
   d = xpts[i] - x[j];
   ksum += dnorm(d / *h, 0, 1, 0);
  }
  result[i] = ksum / ((*n) * (*h));
 }
}</code></pre>
<p>Du code C destiné à être appelé en R avec la fonction <code>.C</code> se doit de respecter les propriétés suivantes (<a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw, 2002</a>) :</p>
<ul>
<li><p>Les fonctions C appelées en R doivent être de type « void ». Elles doivent retourner les résultats des calculs par leurs arguments.</p></li>
<li><p>Les arguments passés aux fonctions C sont des pointeurs à un nombre ou à un tableau. Il faut donc correctement déréférencer les pointeurs dans le code C afin d’obtenir la valeur d’un élément dont l’adresse est contenue dans le pointeur. Un pointeur est déréférencé en ajoutant <code>*</code> devant celui-ci.</p></li>
<li><p>Il est préférable d’inclure dans tout fichier contenant du code C à être appelé en R le fichier d’en-tête R.h en ajoutant au début du fichier de code C la ligne :</p></li>
</ul>
<pre><code>#include &lt;R.h&gt; </code></pre>
<p>De plus, il est possible d’utiliser en C certaines fonctions mathématiques R en incluant le fichier d’en-tête Rmath.h dans le fichier de code C par la ligne :</p>
<pre><code>#include &lt;Rmath.h&gt;</code></pre>
<p>Les fonctions mathématiques R utilisables en C sont énumérées dans le manuel de R <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-R-API"><em>Writing R Extensions</em>, chapitre 6</a>.</p>
<ul>
<li>Le fichier contenant le code C doit porter l’extension « <em>.c</em> ».</li>
</ul>
<p>Une fois le code C écrit, il reste trois étapes à compléter pour intégrer du code C en R avec la fonction <code>.C</code>.</p>
<ol style="list-style-type: decimal">
<li>Compiler le code C afin de créer un objet partagé si nous travaillons sur Linux ou une « bibliothèque de liens dynamiques » (an anglais <em>DLL</em>) si nous travaillons sur Windows ou Mac OS X ;</li>
<li>Charger en R l’objet partagé ou le DLL créé à l’étape précédente avec la fonction <code>dyn.load</code> ;</li>
<li>Appeler en R les fonctions créées dans le code C avec la fonction d’interface <code>.C</code>.</li>
</ol>
<p>Retournons donc à l’exemple. Supposons que le code C ci-dessus se trouve dans le fichier <code>C:/coursR/ksmoothC.c</code>. Dans le <em>terminal</em> sous Linux ou macOS et dans une <em>fenêtre invite de commandes</em> sous Windows, il faut se positionner dans le répertoire contenant le fichier et lancer la commande suivante :</p>
<pre><code>R CMD SHLIB ksmoothC.c</code></pre>
<p>Notons qu’en RStudio, nous pouvons facilement ouvrir un terminal ou une fenêtre invite de commandes par le menu <em>Tools &gt; Shell…</em>.</p>
<p>Cette commande fonctionnera seulement si un compilateur C/C++ est installé sur l’ordinateur. Les <a href="https://stt4230.rbind.io/introduction/installation_r_rstudio/#tools">outils nécessaires au développement de packages R</a> en fournissent un. Si la commande a fonctionné, l’objet partagé ou le DLL sera créé. Sur Windows, il s’agit d’un fichier portant l’extension <em>.dll</em>.</p>
<p>Maintenant, chargeons cet objet en R avec la fonction <code>dyn.load</code>, comme dans cet exemple réalisé sur Windows :</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dyn.load</span>(<span class="st">&quot;C:/coursR/ksmoothC.dll&quot;</span>)</span></code></pre></div>
<p>Il ne reste plus qu’à écrire la « fonction R enveloppe », qui appelle la fonction écrite en C, comme dans cet exemple (fonction <code>ksmooth3</code> de <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf">Peng et de Leeuw 2002</a> renommée ici <code>ksmooth_C</code>) :</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @title Estimation de densité par noyau gaussien</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @description Version 6 : code C + appel à la fonction .C</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&#39; @inherit ksmooth_double_loop params return</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>ksmooth_C <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xpts, h) {</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">length</span>(x)</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>  nxpts <span class="ot">&lt;-</span> <span class="fu">length</span>(xpts)</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>  dens <span class="ot">&lt;-</span> <span class="fu">.C</span>(<span class="st">&quot;kernel_smooth&quot;</span>, <span class="fu">as.double</span>(x), <span class="fu">as.integer</span>(n),</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>             <span class="fu">as.double</span>(xpts), <span class="fu">as.integer</span>(nxpts), <span class="fu">as.double</span>(h),</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>             <span class="at">result =</span> <span class="fu">double</span>(<span class="fu">length</span>(xpts)))</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>  dens<span class="sc">$</span>result</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Dans l’appel à la fonction <code>.C</code>, le nom de la fonction doit obligatoirement être entre guillemets. Il est préférable de s’assurer que chaque argument passé à la fonction C est du bon type en appliquant aux arguments une fonction telle <code>as.integer</code>, <code>as.double</code>, <code>as.character</code> ou <code>as.logical</code>.</p>
<p>Est-ce que la fonction <code>ksmooth_C</code> effectue bien le même calcul que <code>ksmooth_double_loop</code>?</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>densite_kdl <span class="ot">&lt;-</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>densite_kC <span class="ot">&lt;-</span> <span class="fu">ksmooth_C</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(densite_kdl, densite_kC)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Oui.</p>
<p>Maintenant, voyons si cette nouvelle version de <code>ksmooth</code> est plus rapide que certaines des autres fonctions que nous avons développées. Comparons aussi <code>ksmooth_C</code> à la fonction <code>density</code></p>
<!--
Le bloc suivant n'était pas évalué, car il provoquait une erreur lorsqu'évalué
à partir du doc RMarkdown, mais pas lorsqu'évalué dans la console.
-->
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>ex_astuce_6 <span class="ot">&lt;-</span> <span class="fu">mark</span>(</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">ksmooth_double_loop =</span> <span class="fu">ksmooth_double_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>), </span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">ksmooth_outer =</span> <span class="fu">ksmooth_outer</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">ksmooth_loop =</span> <span class="fu">ksmooth_loop</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">ksmooth_C =</span> <span class="fu">ksmooth_C</span>(<span class="at">x =</span> x, <span class="at">xpts =</span> xpts, <span class="at">h =</span> <span class="dv">1</span>),</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">density =</span> <span class="fu">density</span>(<span class="at">x =</span> x, <span class="at">bw =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">&quot;gaussian&quot;</span>, <span class="at">from =</span> <span class="sc">-</span><span class="dv">4</span>, <span class="at">to =</span> <span class="dv">4</span>, <span class="at">n =</span> <span class="dv">17</span>),</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_iterations =</span> <span class="dv">10</span>, <span class="at">time_unit =</span> <span class="st">&quot;ms&quot;</span>, <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Warning: Some expressions had a GC in every iteration; so filtering is disabled.</code></pre>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print_bench_mark</span>(ex_astuce_6)</span></code></pre></div>
<pre><code>##            expression n_itr      min   median mem_alloc n_gc
## 1 ksmooth_double_loop    10 181.5444 190.4726      184B   26
## 2       ksmooth_outer    37  13.0084  13.3512    6.49MB    3
## 3        ksmooth_loop    39  12.5023  12.6614     2.6MB    2
## 4           ksmooth_C    48  10.0945  10.2055  112.05KB    0
## 5             density   907   0.4845   0.4987  315.33KB    4</code></pre>
<!---
```
## Unit: milliseconds
##       expr        min         lq        mean      median          uq        max neval
##   ksmooth_double_loop 160.018944 164.591159 170.1964157 167.9260415 170.7282935 220.236163   100
##   ksmooth_outer  13.402644  13.713477  15.6816264  14.8917480  16.5846660  61.744760   100
##   ksmooth_loop  12.471381  12.584219  14.0803544  12.7721640  14.8104705  58.695675   100
##  ksmooth_C  10.264700  10.315124  10.6443776  10.3643150  10.5529655  13.869510   100
##    density   0.513059   0.635065   0.6897806   0.6770265   0.7061175   1.384377   100
```
--->
<p>La fonction <code>ksmooth_C</code> bat <code>ksmooth_double_loop</code> (double boucle), <code>ksmooth_outer</code> (calcul vectoriel seul avec <code>outer</code>) et <code>ksmooth_loop</code> (boucle et calcul vectoriel), quoiqu’elle n’est pas beaucoup plus rapide que ces deux dernières. Cependant, <code>density</code> demeure beaucoup plus rapide que tout ce que nous avons programmé.</p>
<p>Mais pourquoi <code>density</code> est-il tellement plus rapide alors qu’elle fait appel à du code C, tout comme <code>ksmooth_C</code>? Premièrement, parce que ce code C est interfacé en R par la fonction <code>.Call</code> plutôt que <code>.C</code>. L’interface <code>.Call</code> est plus compliquée d’utilisation que <code>.C</code>, mais plus efficace. La fonction <code>density</code> est aussi plus rapide parce que son code C a lui aussi été optimisé.</p>
<hr />
</div>
</div>
<div id="résumé" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Résumé</h1>
<div id="optimisation-de-temps-dexécution" class="section level4 unnumbered">
<h4>Optimisation de temps d’exécution</h4>
<p></p>
<p>Outils pour analyser la performance d’un programme R :</p>
<ul>
<li>calcul global de temps d’exécution :
<ul>
<li>la fonction <code>system.time</code> (R de base),</li>
<li>la fonction <code>mark</code> du package <code>bench</code>;</li>
</ul></li>
<li>calcul plus détaillé de temps d’exécution :
<ul>
<li>par fonction appelée (<em>call stack</em>) : les fonctions <code>Rprof</code> et <code>summaryRprof</code> (R de base),</li>
<li>par ligne de code : la fonction <code>profvis</code> (package du même nom).</li>
</ul></li>
</ul>
<p><strong>Conseil</strong> : comparaison de différentes options.<br />
<span class="math inline">\(\longrightarrow\)</span> Le code le plus rapide n’est pas toujours celui que nous croyons.</p>
<p>Contrainte : <strong>compromis temps d’exécution - quantité de mémoire utilisée</strong></p>
</div>
<div id="stratégies-doptimisation-du-temps-dexécution-1" class="section level4 unnumbered">
<h4>Stratégies d’optimisation du temps d’exécution</h4>
<p></p>
<p><strong>Astuces</strong> pour du code R plus rapide :</p>
<ol style="list-style-type: decimal">
<li>Utiliser des fonctions optimisées</li>
<li>Faire seulement ce qui est nécessaire</li>
<li>Exploiter les calculs matriciels et vectoriels</li>
<li>Éviter les allocations de mémoire inutiles</li>
<li>Faire du calcul en parallèle</li>
<li>Reprogrammer en C ou C++ les bouts de code les plus lents</li>
</ol>
<div id="astuce-1-utiliser-des-fonctions-optimisées-1" class="section level5 unnumbered">
<h5>Astuce 1 : Utiliser des fonctions optimisées</h5>
<p></p>
<p>Profiter du travail des autres</p>
<p>Le web regorge de fonctions R : la distribution de base de R, le CRAN, Bioconductor, GitHub, etc.</p>
</div>
<div id="astuce-2-faire-seulement-ce-qui-est-nécessaire-1" class="section level5 unnumbered">
<h5>Astuce 2 : Faire seulement ce qui est nécessaire</h5>
<p></p>
<p>Ne pas alourdir son code d’évaluations inutiles</p>
</div>
<div id="astuce-3-exploiter-les-calculs-matriciels-et-vectoriels-1" class="section level5 unnumbered">
<h5>Astuce 3 : Exploiter les calculs matriciels et vectoriels</h5>
<p></p>
<p>R est optimisé pour le calcul vectoriel</p>
<p>(fonctions de la famille des <code>apply</code> = boucles, pas calcul vectoriel)</p>
</div>
<div id="astuce-4-éviter-les-allocations-de-mémoire-inutiles-1" class="section level5 unnumbered">
<h5>Astuce 4 : Éviter les allocations de mémoire inutiles</h5>
<p></p>
<p>Allouer de l’espace dans la mémoire d’un ordinateur = opération coûteuse en temps</p>
<p>Opérations à éviter dans une boucle R :</p>
<ol style="list-style-type: decimal">
<li>utilisation d’un objet de dimension croissante : utiliser plutôt un objet de taille fixe;</li>
<li>assignation de valeur(s) dans un data frame : utiliser plutôt un objet atomique ou un data table.</li>
</ol>
</div>
<div id="astuce-5-faire-du-calcul-en-parallèle-1" class="section level5 unnumbered">
<h5>Astuce 5 : Faire du calcul en parallèle</h5>
<p></p>
<p>Version la plus simple du calcul en parallèle :</p>
<ul>
<li>brise un long calcul en petits blocs de calcul indépendants;</li>
<li>réalise ces blocs de calcul sur plusieurs unités de calcul (coeurs d’un processeur) simultanément (donc en parallèle);</li>
<li>rassemble à la fin tous les résultats.</li>
</ul>
<p>Domaine très large : <a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html" class="uri">https://cran.r-project.org/web/views/HighPerformanceComputing.html</a></p>
<p>Domaine très technique : dépend des ressources à notre portée (CPU versus GPU, plusieurs coeurs sur notre ordinateur, grappe de serveurs de calcul, plateforme de cloud computing, etc.)</p>
<p>Point de départ en R : package <code>parallel</code></p>
</div>
<div id="astuce-6-reprogrammer-en-c-ou-c-les-bouts-de-code-les-plus-lents-1" class="section level5 unnumbered">
<h5>Astuce 6 : Reprogrammer en C ou C++ les bouts de code les plus lents</h5>
<p></p>
<p>Meilleure solution pour développer une fonction très rapide, pas pour réaliser rapidement des analyses de données.</p>
<ul>
<li>fonction d’interface <code>.C</code>,</li>
<li>fonction d’interface <code>.Call</code> ou <code>.External</code>,</li>
<li>package <code>Rcpp</code> pour l’intégration de code C++.</li>
</ul>
<hr />
</div>
</div>
</div>
<div id="références" class="section level1 unnumbered">
<h1>Références</h1>
<div id="référence-citée-dans-le-texte" class="section level4 unnumbered">
<h4>Référence citée dans le texte :</h4>
<p></p>
<div id="refs" class="references csl-bib-body">
<div id="ref-matloff" class="csl-entry">
<div class="csl-right-inline">[1] Matloff, N. (2011). <em><span class="nocase">The Art of R Programming: A Tour of Statistical Software Design</span></em>. No Starch Press. Sections 1.3 et 7.4</div>
</div>
</div>
</div>
<div id="références-supplémentaires" class="section level4 unnumbered">
<h4>Références supplémentaires :</h4>
<p></p>
<ul>
<li><strong>Outils d’analyse de la performance d’un programme R</strong>
<ul>
<li>Hester, J. (2020). <code>bench</code>: <em>High Precision Timing of R Expressions</em>. R package version 1.1.1. URL <a href="https://CRAN.R-project.org/package=bench" class="uri">https://CRAN.R-project.org/package=bench</a>
<ul>
<li>URL documentation en ligne <a href="http://bench.r-lib.org/" class="uri">http://bench.r-lib.org/</a></li>
</ul></li>
<li>Chang, W., Luraschi, J. et Mastny, T. (2020). <code>profvis</code>: <em>Interactive Visualizations for Profiling R Code</em>. R package version 0.3.7. &lt;URL <a href="https://CRAN.R-project.org/package=profvis" class="uri">https://CRAN.R-project.org/package=profvis</a>&gt;
<ul>
<li>URL documentation en ligne <a href="https://rstudio.github.io/profvis/" class="uri">https://rstudio.github.io/profvis/</a></li>
</ul></li>
</ul></li>
<li><strong>Optimisation de temps d’exécution</strong>
<ul>
<li>Wickham, H. (2019). <em>Advanced R</em>. 2<sup>e</sup> édition. Chapman and Hall/CRC.
<ul>
<li>Chapitre 2 <em>Names and Values</em>, URL <a href="https://adv-r.hadley.nz/names-values.html" class="uri">https://adv-r.hadley.nz/names-values.html</a></li>
<li>Chapitre 23 <em>Measuring Performance</em>, URL <a href="https://adv-r.hadley.nz/perf-measure.html" class="uri">https://adv-r.hadley.nz/perf-measure.html</a></li>
<li>Chapitre 24 <em>Improving Performance</em>, URL <a href="https://adv-r.hadley.nz/perf-improve.html" class="uri">https://adv-r.hadley.nz/perf-improve.html</a></li>
</ul></li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>, No Starch Press. Chapitre 14.</li>
<li>Ross, N. (2014). Tutoriel web intitulé « <em>Vectorization in R: Why?</em> »<br />
URL <a href="http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html" class="uri">http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html</a></li>
<li>Adler, J. (2012). <em>R in a Nutshell</em>. 2<sup>e</sup> édition. O’Reilly. Chapitre 24.</li>
</ul></li>
<li><strong>Interfacer du code dans un autre langage (en particulier C ou C++)</strong>
<ul>
<li>Peng, R. D., &amp; de Leeuw, J. (2002). <em>An Introduction to the .C Interface to R</em>. UCLA: Academic Technology Services, Statistical Consulting Group. URL <a href="http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf" class="uri">http://www.biostat.jhsph.edu/~rpeng/docs/interface.pdf</a></li>
<li>R Core Team (2021). <em>Writing R Extensions</em>. R Foundation for Statistical Computing. Chapitre 5 et 6. URL <a href="http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces" class="uri">http://cran.r-project.org/doc/manuals/r-release/R-exts.html#System-and-foreign-language-interfaces</a></li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>, No Starch Press. Chapitre 15.</li>
<li>Utilisation du package <code>Rcpp</code> :
<ul>
<li>URL documentation en ligne du pacakge <a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a></li>
<li>Wickham, H. (2019). <em>Advanced R</em>. 2<sup>e</sup> édition. Chapman and Hall/CRC. Chapitre 19. <em>Rewriting R code in C++</em>, URL <a href="https://adv-r.hadley.nz/rcpp.html" class="uri">https://adv-r.hadley.nz/rcpp.html</a></li>
</ul></li>
</ul></li>
<li><strong>Calcul en parallèle</strong>
<ul>
<li>Baillargeon, S. (2017). Tutoriel intitulé « <em>Calcul en parallèle sur CPU avec R</em> ». URL <a href="https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/" class="uri">https://stt4230.rbind.io/autre_materiel/calcul_parallele_r/</a></li>
<li>McCallum, E., &amp; Weston, S. (2011). <em>Parallel R</em>. O’Reilly.</li>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>, No Starch Press. Chapitre 16.</li>
</ul></li>
</ul>
</div>
</div>
