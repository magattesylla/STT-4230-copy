---
title: "Structures de contrôle en R"
author: "Sophie Baillargeon, Université Laval"
date: "2021-03-12"
weight: 2
slug: "struct_controle_r"
lastmodifierdisplayname: "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style>

<div id="TOC">
<ul>
<li><a href="#alternatives"><span class="toc-section-number">1</span> Alternatives</a>
<ul>
<li><a href="#structure-if-...-else"><span class="toc-section-number">1.1</span> Structure <code>if ... else</code></a>
<ul>
<li><a href="#écriture-générale-dun-if-...-else"><span class="toc-section-number">1.1.1</span> Écriture générale d’un <code>if ... else</code></a></li>
<li><a href="#écriture-condensée-dun-if-...-else"><span class="toc-section-number">1.1.2</span> Écriture condensée d’un <code>if ... else</code></a></li>
<li><a href="#distinction-entre-une-structure-if-...-else-et-la-fonction-ifelse"><span class="toc-section-number">1.1.3</span> Distinction entre une structure <code>if ... else</code> et la fonction <code>ifelse</code></a></li>
</ul></li>
<li><a href="#fonction-switch"><span class="toc-section-number">1.2</span> Fonction <code>switch</code></a></li>
</ul></li>
<li><a href="#boucles"><span class="toc-section-number">2</span> Boucles</a>
<ul>
<li><a href="#boucles-for"><span class="toc-section-number">2.1</span> Boucles <code>for</code></a></li>
<li><a href="#enregistrement-des-résultats-dans-une-boucle"><span class="toc-section-number">2.2</span> Enregistrement des résultats dans une boucle</a></li>
<li><a href="#affichage-de-résultats-dans-une-boucle"><span class="toc-section-number">2.3</span> Affichage de résultats dans une boucle</a></li>
<li><a href="#boucles-while-ou-repeat"><span class="toc-section-number">2.4</span> Boucles <code>while</code> ou <code>repeat</code></a></li>
<li><a href="#imbriquer-des-boucles"><span class="toc-section-number">2.5</span> Imbriquer des boucles</a></li>
<li><a href="#mots-clés-break-et-next"><span class="toc-section-number">2.6</span> Mots-clés <code>break</code> et <code>next</code></a></li>
<li><a href="#interruption-de-lexécution-dune-boucle"><span class="toc-section-number">2.7</span> Interruption de l’exécution d’une boucle</a></li>
<li><a href="#éviter-les-boucles"><span class="toc-section-number">2.8</span> Éviter les boucles</a>
<ul>
<li><a href="#calcul-vectoriel-versus-boucle"><span class="toc-section-number">2.8.1</span> Calcul vectoriel versus boucle</a></li>
<li><a href="#fonction-de-la-famille-des-apply-versus-boucle"><span class="toc-section-number">2.8.2</span> Fonction de la famille des <code>apply</code> versus boucle</a></li>
</ul></li>
</ul></li>
<li><a href="#résumé"><span class="toc-section-number">3</span> Résumé</a></li>
<li><a href="#références">Références</a></li>
</ul>
</div>

<hr />
<p><em>Note préliminaire : Lors de leur dernière mise à jour, ces notes ont été révisées en utilisant R version 4.0.3.</em></p>
<hr />
<p>La matière vue jusqu’à maintenant dans le cours traitait principalement de l’utilisation du logiciel R dans le but de faire de la manipulation ou de l’analyse de données. Cette utilisation passe par la soumission de commandes dans la console R. En fait, souvent plus d’une commande est nécessaire pour produire le résultat escompté. Plutôt que de soumettre une après l’autre plusieurs commandes dans la console, nous avons appris qu’il était préférable d’écrire des programmes. Renommons « instructions » les commandes apparaissant dans un programme. Lorsqu’un programme R entier est soumis, les instructions qui le composent sont exécutées séquentiellement, c’est-à-dire l’une après l’autre, en respectant leur ordre d’apparition dans le programme.</p>
<p>Comme presque tout langage informatique qui adhèrent au <a href="https://fr.wikipedia.org/wiki/Programmation_imp%C3%A9rative">paradigme de programmation impératif</a>, R offre des <a href="https://fr.wikipedia.org/wiki/Structure_de_contr%C3%B4le">structures de contrôles</a> (aussi appelées séquencements). Les structures de contrôle sont des instructions particulières qui contrôlent l’ordre dans lequel d’autres instructions d’un programme informatique sont exécutées. Les appels de fonction, présents dans pratiquement toutes les instructions R étudiées dans ce cours jusqu’à maintenant, sont des structures de contrôle. Elles produisent un saut dans l’exécution des instructions d’un programme vers un sous-programme (le corps de la fonction), suivi d’un saut de retour vers le programme principal.</p>
<p>Ce document décrit l’utilisation en R des deux autres structures de contrôle les plus courantes en programmation impérative : les alternatives (structures conditionnelles) et les boucles (structures itératives). Dans les gabarits de code présentés dans cette fiche, les éléments encadrés des signes <code>&lt;</code> et <code>&gt;</code> sont des bouts à remplacer par ce qui convient pour la tâche à accomplir</p>
<div id="alternatives" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Alternatives</h1>
<p>Les <a href="https://fr.wikipedia.org/wiki/Structure_de_contr%C3%B4le#Alternatives">alternatives</a> ont pour but d’exécuter des instructions seulement si une certaine condition est satisfaite. Voyons ici deux outils pour créer des alternatives en R : la structure <code>if ... else</code> et la fonction <code>switch</code>.</p>
<div id="structure-if-...-else" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Structure <code>if ... else</code></h2>
<div id="écriture-générale-dun-if-...-else" class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Écriture générale d’un <code>if ... else</code></h3>
<p>Les mots-clés pour écrire des alternatives en R sont <code>if</code> et <code>else</code>. De façon générale, la syntaxe d’une structure de contrôle <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html"><code>if ... else</code></a> est la suivante.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si l&#39;évaluation de &lt;condition&gt; retourne TRUE</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si l&#39;évaluation de &lt;condition&gt; retourne FALSE</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Il est possible d’avoir un <code>if</code> sans <code>else</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si l&#39;évaluation de &lt;condition&gt; retourne TRUE</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Un <code>if</code> doit être suivi d’une paire de parenthèses dans laquelle est inséré une expression R retournant une seule valeur logique (<code>TRUE</code> ou <code>FALSE</code>). C’est la condition de l’alternative. Ensuite viennent la ou les instructions à exécuter si la condition est vraie (c’est-à-dire si l’instruction <code>&lt;condition&gt;</code> produit le résultat <code>TRUE</code>). S’il y a plus d’une instruction à exécuter, les accolades sont nécessaires pour les encadrer. Pour une seule instruction, les accolades sont optionnelles.</p>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation du lancer d&#39;une pièce de monnaie</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lancer <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="st">&quot;Pile&quot;</span>, <span class="st">&quot;Face&quot;</span>), <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Structure qui affiche ou non un message, en fonction du résultat du lancer</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">isTRUE</span>(lancer <span class="sc">==</span> <span class="st">&quot;Pile&quot;</span>))    <span class="co"># sans accolades</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">&quot;Je gagne!&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ou encore</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">isTRUE</span>(lancer <span class="sc">==</span> <span class="st">&quot;Pile&quot;</span>)) {  <span class="co"># avec accolades</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">&quot;Je gagne!&quot;</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Lorsqu’il y a des instructions à exécuter si la condition est fausse, il faut ajouter un <code>else</code> à l’alternative, suivi des instructions en question. Dans ce cas, il est considéré comme une bonne pratique de toujours encadrer les blocs d’instructions d’accolades (sauf si l’écriture condensée, qui sera présentée plus loin, est utilisée), même s’ils sont composés d’une seule instruction, de façon à retrouver le mot-clé <code>else</code> précédé de <code>}</code> et suivi de <code>{</code> .</p>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">isTRUE</span>(lancer <span class="sc">==</span> <span class="st">&quot;Pile&quot;</span>)) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">&quot;Je gagne!&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">&quot;Je perds...&quot;</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div id="condition-dun-if-...-else" class="section level4 unnumbered">
<h4>Condition d’un <code>if ... else</code></h4>
<p></p>
<p>La condition d’un <code>if ... else</code> doit donc être une expression R retournant une seule valeur logique (<code>TRUE</code> ou <code>FALSE</code>). En fait, il peut aussi s’agir d’une expression pouvant être convertie en logique (avec la fonction <code>as.logical</code>). Si la condition est de longueur supérieure à 1, un avertissement est généré et seulement le premier élément de la condition est considéré (les autres éléments sont ignorés).</p>
<p>Les opérateurs et fonctions R mentionnées à la section 3.2 des <a href="https://stt4230.rbind.io/calculs/calculs_math_r/#conditions-logiques-de-longueur-1">notes sur les calculs mathématiques en R</a> (section intitulée « Conditions logiques de longueur 1 ») sont très utiles pour écrire des conditions d’alternatives. En effet, les opérateurs <code>&amp;&amp;</code> et <code>||</code>, ainsi que les fonctions <code>isTRUE</code>, <code>isFALSE</code>, <code>all</code>, <code>any</code> et toutes les fonctions de la famille des <code>is.*</code>, garantissent la production d’une seule valeur logique.</p>
<p>Dans la condition de l’alternative de l’exemple précédent, l’expression <code>lancer == "Pile"</code> retourne un vecteur logique de la même longueur que le vecteur <code>lancer</code>. Ici, un vecteur de longueur 1 a été assigné à <code>lancer</code> lors de sa création, alors <code>lancer == "Pile"</code> est de longueur 1. Par mesure de précaution, nous avons tout de même encadré l’expression <code>lancer == "Pile"</code> par un appel à la fonction <code>isTRUE</code> afin de s’assurer que la condition de l’alternative soit de longueur 1 peu importe le contexte. Rappelons que la fonction <code>isTRUE</code> retourne <code>TRUE</code> si la valeur qu’elle reçoit en entrée contient des données logiques, est de longueur 1, ne prend pas la valeur <code>NA</code>, mais bien la valeur <code>TRUE</code>. Elle retourne <code>FALSE</code> si au moins une de ses caractéristiques n’est pas rencontrée.</p>
</div>
<div id="structures-if-...-else-imbriquées" class="section level4 unnumbered">
<h4>Structures <code>if ... else</code> imbriquées</h4>
<p></p>
<p>Plusieurs structures <code>if ... else</code> peuvent être imbriquées. Pour ce faire, il suffit d’insérer une autre structure <code>if ... else</code> à la place de l’accolade suivant le dernier <code>else</code>, comme suit.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">&lt;</span>condition_1<span class="sc">&gt;</span>) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; retourne TRUE</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="sc">&lt;</span>condition_2<span class="sc">&gt;</span>) {</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; retourne FALSE, mais &lt;condition_2&gt; retourne TRUE</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; et &lt;condition_2&gt; retournent FALSE</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Notons que la syntaxe précédente est préférée à la suivante, qui est équivalente mais plus lourde.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Syntaxe non allégée de deux structures if ... else imbriquées</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">&lt;</span>condition_1<span class="sc">&gt;</span>) {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; retourne TRUE</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">&lt;</span>condition_2<span class="sc">&gt;</span>) {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; retourne FALSE, mais &lt;condition_2&gt; retourne TRUE</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition_1&gt; et &lt;condition_2&gt; retournent FALSE</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> iris<span class="sc">$</span>Sepal.Length</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Programme qui calcule des statistiques descriptives simples, selon</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># le type des éléments du vecteur sur lequel le calcul est fait</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">is.numeric</span>(x)) {</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">is.character</span>(x) <span class="sc">||</span> <span class="fu">is.factor</span>(x)) {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">table</span>(x)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Faisons rouler les instructions de nouveau, après avoir redéfini le vecteur x.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> iris<span class="sc">$</span>Species</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">is.numeric</span>(x)) {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x))</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">is.character</span>(x) <span class="sc">||</span> <span class="fu">is.factor</span>(x)) {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">table</span>(x)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## x
##     setosa versicolor  virginica 
##         50         50         50</code></pre>
<p>Il serait pratique de créer une fonction à partir de ce bout de code. Nous le ferons dans les <a href="https://stt4230.rbind.io/programmation/fonctions_r/">notes sur les fonctions en R</a>.</p>
</div>
</div>
<div id="écriture-condensée-dun-if-...-else" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Écriture condensée d’un <code>if ... else</code></h3>
<p>Lorsque, dans chaque branche d’une alternative <code>if ... else</code>, il n’y a seulement une instruction courte servant à créer un seul objet, l’écriture condensée suivante peut être pratique :</p>
<pre><code>nom &lt;- if (&lt;condition&gt;) &lt;instruction&gt; else &lt;instruction&gt;</code></pre>
<p>Cette écriture est recommandée seulement si elle rend le code plus lisible pour des alternatives très simples.</p>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>message <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">isTRUE</span>(lancer <span class="sc">==</span> <span class="st">&quot;Pile&quot;</span>)) <span class="st">&quot;Je gagne!&quot;</span> <span class="cf">else</span> <span class="st">&quot;Je perds...&quot;</span></span></code></pre></div>
</div>
<div id="distinction-entre-une-structure-if-...-else-et-la-fonction-ifelse" class="section level3" number="1.1.3">
<h3><span class="header-section-number">1.1.3</span> Distinction entre une structure <code>if ... else</code> et la fonction <code>ifelse</code></h3>
<p>Sous sa forme condensée, une structure <code>if ... else</code> fait penser à un appel à la <a href="https://stt4230.rbind.io/manipulation_donnees/pretraitement_donnees_r/#variable-conditionnelle-%C3%A0-une-autre-avec-la-fonction-ifelse">fonction <code>ifelse</code></a>. Quelles sont les différences entre les deux?</p>
<p>En fait, la fonction <code>ifelse</code> n’est pas une structure de contrôle. Elle teste une condition sur tous les éléments d’un objet et retourne une valeur par élément en fonction du résultat du test. La fonction <code>ifelse</code> accepte comme premier argument (<code>test</code>) un objet atomique logique de dimension quelconque. La dimension de la sortie d’un <code>ifelse</code> est la même que la dimension du premier argument qu’elle reçoit. Cette fonction agit de façon vectorielle.</p>
<p>Supposons que nous voulons vérifier pour chaque élément d’un vecteur nommé <code>x</code> si sa valeur est comprise entre 2.5 et 7.5 exclusivement; si c’est le cas retourner la valeur 5, sinon retourner l’élément de <code>x</code> inchangé. Nous pourrions faire ça avec la fonction <code>ifelse</code> comme suit.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>  <span class="co"># initialisation d&#39;un vecteur x numérique quelconque</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ifelse</span>(<span class="at">test =</span> x <span class="sc">&gt;</span> <span class="fl">2.5</span> <span class="sc">&amp;</span> x <span class="sc">&lt;</span> <span class="fl">7.5</span>, <span class="at">yes =</span> <span class="dv">5</span>, <span class="at">no =</span> x)</span></code></pre></div>
<pre><code>##  [1]  1  2  5  5  5  5  5  8  9 10</code></pre>
<p>Si, par erreur, nous avions utilisé la structure <code>if ... else</code> au lieu de la fonction <code>ifelse</code> pour réaliser cette tâche, nous aurions obtenu ce qui suit.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x <span class="sc">&gt;</span> <span class="fl">2.5</span> <span class="sc">&amp;</span> x <span class="sc">&lt;</span> <span class="fl">7.5</span>) <span class="dv">5</span> <span class="cf">else</span> x</span></code></pre></div>
<pre><code>## Warning in if (x &gt; 2.5 &amp; x &lt; 7.5) 5 else x: the condition has length &gt; 1 and
## only the first element will be used</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p>Remarquons premièrement qu’un avertissement a été généré, car la condition dans la structure <code>if ... else</code> n’est pas de longueur 1. Seul le premier élément du vecteur créé par l’expression <code>x &gt; 2.5 &amp; x &lt; 7.5</code> a été utilisé.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>x <span class="sc">&gt;</span> <span class="fl">2.5</span> <span class="sc">&amp;</span> x <span class="sc">&lt;</span> <span class="fl">7.5</span></span></code></pre></div>
<pre><code>##  [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE</code></pre>
<p>Ce premier élément est <code>FALSE</code>. Ainsi, c’est l’instruction après le <code>else</code> de l’alternative qui a été exécutée. Donc <code>x</code> a été retourné intacte.</p>
<p>Si nous avions utilisé l’opérateur logique <code>&amp;&amp;</code> au lieu de <code>&amp;</code> dans la condition, nous n’aurions pas obtenu d’avertissement, mais le même résultat aurait été retourné.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x <span class="sc">&gt;</span> <span class="fl">2.5</span> <span class="sc">&amp;&amp;</span> x <span class="sc">&lt;</span> <span class="fl">7.5</span>) <span class="dv">5</span> <span class="cf">else</span> x</span></code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p>L’opérateur <code>&amp;&amp;</code> a restreint l’évaluation de la condition au premier élément de <code>x</code> (les autres éléments ont été ignorés).</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x <span class="sc">&gt;</span> <span class="fl">2.5</span> <span class="sc">&amp;&amp;</span> x <span class="sc">&lt;</span> <span class="fl">7.5</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
<div id="fonction-switch" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Fonction <code>switch</code></h2>
<p>La fonction <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/switch.html">switch</a> est parfois utile pour remplacer plusieurs structures <code>if ... else</code> imbriquées. La syntaxe générale d’un appel à la fonction <code>switch</code> est la suivante.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span>(</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>expression<span class="sc">&gt;</span>,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;resultat_1&quot;</span> <span class="ot">=</span> {</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne &quot;resultat_1&quot;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;resultat_2&quot;</span> <span class="ot">=</span> {</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne &quot;resultat_2&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  .</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  .  <span class="co"># autres paires (résultat, instructions à exécuter) s&#39;il y a lieu</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  .</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne tout autre résultat</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Dans cette syntaxe générale, la valeur fournie au premier argument, représentée par <code>&lt;expression&gt;</code>, doit être une instruction R retournant une chaîne de caractères. Les autres arguments de la fonction doivent porter les noms de ce que peut produire en sortie <code>&lt;expression&gt;</code>. Les valeurs fournies à ces arguments sont les instructions à exécuter si <code>&lt;expression&gt;</code> retourne une chaîne de caractères égale au nom de l’argument. Si un dernier argument non assigné à un nom est fourni, il sera exécuté si <code>&lt;expression&gt;</code> retourne une chaîne de caractères ne se retrouvant pas parmi les noms d’arguments présents dans l’appel à la fonction <code>switch</code>. Notons que lorsqu’un résultat doit provoquer l’exécution d’une seule instruction, celle-ci n’a pas à être encadrée d’accolades.</p>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> iris<span class="sc">$</span>Sepal.Length</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Structures if ... else imbriquées présentées précédemment, à reproduire</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">is.numeric</span>(x)) {</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x))</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">is.character</span>(x) <span class="sc">||</span> <span class="fu">is.factor</span>(x)) {</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">table</span>(x)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Appel à la fonction switch équivalent</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span>(</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(x),</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;numeric&quot;</span>   <span class="ot">=</span> <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x)),</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;integer&quot;</span>   <span class="ot">=</span> <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x)),</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;character&quot;</span> <span class="ot">=</span> <span class="fu">table</span>(x),</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;factor&quot;</span>    <span class="ot">=</span> <span class="fu">table</span>(x),</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<p>Dans cet exemple, <code>&lt;expression&gt;</code> est l’instruction <code>class(x)</code>. Celle-ci retourne <code>"numeric"</code> pour un vecteur <code>x</code> contenant des données de type réel, mais retourne <code>"integer"</code> pour un vecteur <code>x</code> contenant des données de type entier. La condition <code>is.numeric(x)</code> retourne quant à elle <code>TRUE</code> pour tout vecteur numérique <code>x</code>, que ses données soient réelles ou entières. Afin de créer un appel à la fonction <code>switch</code> équivalent aux structures <code>if ... else</code> imbriquées à reproduire, il fallait donc définir les résultats <code>"numeric"</code> et <code>"integer"</code>. Les deux solutions implémentent la même alternative aussi parce que <code>is.character(x)</code> est équivalent à <code>class(x) == "character"</code> et <code>is.factor(x)</code> est équivalent à <code>class(x) == "factor"</code>.</p>
<p>Notons que <code>&lt;expression&gt;</code> peut aussi retourner un entier, interprété comme le numéro du bloc d’instructions à exécuter. Par exemple, si <code>&lt;expression&gt;</code> produit le résultat <code>2</code> lorsqu’exécuté, c’est le deuxième bloc d’instructions (troisième argument fourni à la fonction <code>switch</code>) qui sera exécuté. Dans ce cas, les blocs d’instructions n’ont pas besoin d’être assignés à des noms. L’appel à la fonction <code>switch</code> suivant est donc aussi équivalent aux structures <code>if ... else</code> imbriquées présentées dans l’exemple précédent.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span>(</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.numeric</span>(x)) <span class="dv">1</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">is.character</span>(x) <span class="sc">||</span> <span class="fu">is.factor</span>(x)) <span class="dv">2</span> <span class="cf">else</span> <span class="dv">3</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">min =</span> <span class="fu">min</span>(x), <span class="at">moy =</span> <span class="fu">mean</span>(x), <span class="at">max =</span> <span class="fu">max</span>(x)),</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">table</span>(x),</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="boucles" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Boucles</h1>
<p>Les <a href="https://fr.wikipedia.org/wiki/Structure_de_contr%C3%B4le#Boucles">boucles</a> ont pour but de répéter des instructions à plusieurs reprises, c’est donc dire de les itérer. Parfois, le nombre d’itérations à effectuer est connu d’avance. D’autres fois, ce nombre d’itérations n’est pas connu d’avance, car il dépend d’une condition à rencontrer.</p>
<div id="boucles-for" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Boucles <code>for</code></h2>
<p>Lorsque le nombre d’itérations à effectuer est prédéterminé, une boucle <code>for</code> est tout indiquée.</p>
<div id="écriture-générale-dune-boucle-for" class="section level4 unnumbered">
<h4>Écriture générale d’une boucle <code>for</code> :</h4>
<p></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="sc">&lt;</span>iterateur<span class="sc">&gt;</span> <span class="cf">in</span> <span class="sc">&lt;</span>ensemble<span class="sc">&gt;</span>) {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées à chaque itération de la boucle</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Ce type de boucle débute par le mot clé <code>for</code>, suivi des éléments suivants, dans l’ordre :</p>
<ul>
<li>une parenthèse ouvrante;</li>
<li>un nom quelconque, représenté par <code>&lt;iterateur&gt;</code> dans la syntaxe générale;</li>
<li>le mot-clé <code>in</code>;</li>
<li>une instruction retournant un vecteur contenant l’ensemble des valeurs sur lesquelles itérer, représenté par <code>&lt;ensemble&gt;</code> dans la syntaxe générale;</li>
<li>une parenthèse fermante.</li>
</ul>
<p>Ensuite viennent la ou les instructions à répéter. S’il y a plus d’une instruction à répéter, les accolades sont nécessaires pour les encadrer. Dans ces instructions, l’objet nommé <code>&lt;iterateur&gt;</code> dans la syntaxe générale intervient généralement.</p>
<p>La boucle effectue autant de répétitions que la longueur du vecteur <code>&lt;ensemble&gt;</code>.</p>
<ul>
<li>Première itération : <code>&lt;iterateur&gt;</code> prend la valeur <code>&lt;ensemble&gt;[[1]]</code>.</li>
<li>Deuxième itération : <code>&lt;iterateur&gt;</code> prend la valeur <code>&lt;ensemble&gt;[[2]]</code>.</li>
<li><span class="math inline">\(\vdots\)</span></li>
<li>Dernière itération : <code>&lt;iterateur&gt;</code> prend la valeur <code>&lt;ensemble&gt;[[length(&lt;ensemble&gt;)]]</code>.</li>
</ul>
<p>Ainsi, de façon générale, pour les itérations <code>i</code> allant de <code>1</code> à <code>length(&lt;ensemble&gt;)</code>, <code>valeur</code> contient <code>&lt;ensemble&gt;[[i]]</code>.</p>
<p>Voici un exemple :</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (lettre <span class="cf">in</span> LETTERS) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(lettre, <span class="st">&quot; &quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</code></pre>
<p>Dans cet exemple, nous avons effectué 26 itérations, car <code>length(LETTERS)</code> <code>==</code> 26. À l’itération <code>i</code>, nous avons affiché le <code>i</code><sup>e</sup> élément du vecteur <code>LETTERS</code>, soit la <code>i</code><sup>e</sup> lettre de l’alphabet.</p>
<p>Nous aurions pu effectuer exactement la même boucle en itérant sur les entiers de 1 à 26 comme suit :</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(LETTERS)) {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(LETTERS[[i]], <span class="st">&quot; &quot;</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z</code></pre>
<p>Lorsque nous choisissons d’itérer sur les entiers allant de 1 au nombre total d’itérations à effectuer (disons <code>n</code>), il est commun d’utiliser le nom <code>i</code> pour l’objet changeant de valeur au fil des itérations. Le vecteur <code>&lt;ensemble&gt;</code> est alors souvent créé par l’instruction <code>1:n</code>, mais il est plus prudent d’utiliser <code>seq_len(n)</code> qui retournera une erreur si <code>n</code> est négatif ou un vecteur vide si <code>n == 0</code>. Si le nombre d’itérations à effectuer <code>n</code> est égal à la longueur d’un objet, disons <code>a</code>, il est recommandé de créer le vecteur <code>&lt;ensemble&gt;</code> par l’instruction <code>seq_along(a)</code>. Pour un objet <code>a</code> de longueur non nulle, les instructions <code>1:length(a)</code> et <code>seq_along(a)</code> retournent exactement le même résultat, comme l’illustre cet exemple.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(LETTERS)</span></code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">seq_along</span>(LETTERS)</span></code></pre></div>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</code></pre>
<p>Cependant, si l’objet <code>a</code> s’adonne à être de longueur nulle, l’utilisation de <code>seq_along(a)</code> nous assure que la boucle n’effectue aucune itération. L’utilisation de <code>1:length(a)</code> entraînerait plutôt une itération sur <code>i = 1</code>, puis <code>i = 0</code>, qui risquerait de générer une erreur. Ce comportement s’explique par le fait que <code>1:length(a)</code> retourne dans ce cas particulier le vecteur (1, 0).</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">list</span>()  <span class="co"># supposons que a est une liste vide</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(a)</span></code></pre></div>
<pre><code>## [1] 1 0</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">seq_along</span>(a)</span></code></pre></div>
<pre><code>## integer(0)</code></pre>
<p><strong>Autre exemple</strong>:</p>
<p>Voici un exemple de boucle <code>for</code>, utilisant le jeu de données <code>attitude</code> (provenant du package <code>datasets</code>)</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(attitude)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    30 obs. of  7 variables:
##  $ rating    : num  43 63 71 61 81 43 58 71 72 67 ...
##  $ complaints: num  51 64 70 63 78 55 67 75 82 61 ...
##  $ privileges: num  30 51 68 45 56 49 42 50 72 45 ...
##  $ learning  : num  39 54 69 47 66 44 56 55 67 47 ...
##  $ raises    : num  61 63 76 54 71 54 66 70 71 62 ...
##  $ critical  : num  92 73 86 84 83 49 68 66 83 80 ...
##  $ advance   : num  45 47 48 35 47 34 35 41 31 41 ...</code></pre>
<p>Ce jeu de données contient 7 variables numériques. Ces données ont été recueillies dans le but d’étudier les variables influençant la cote (<code>rating</code>) reçue par 30 départements d’une grande organisation financière. Supposons que nous souhaitons réaliser 6 régressions linéaires simples sur ces données. Toutes les régressions auraient la même variable réponse, <code>rating</code> (en position 1), et la variable explicative devrait être tour à tour une des autres variables du jeu de données.</p>
<p>L’instruction pour réaliser la régression simple avec la variable <code>complaints</code> par exemple, serait la suivante :</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lm</span>(rating <span class="sc">~</span> complaints, <span class="at">data =</span> attitude)</span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ou</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lm</span>(rating <span class="sc">~</span> ., <span class="at">data =</span> attitude[, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)])</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, 2)])
## 
## Coefficients:
## (Intercept)   complaints  
##     14.3763       0.7546</code></pre>
<p>Nous souhaitons maintenant insérer cette instruction dans une boucle permettant d’effectuer les 6 régressions simples.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>modeles <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">length =</span> <span class="fu">ncol</span>(attitude) <span class="sc">-</span> <span class="dv">1</span>, <span class="at">mode =</span> <span class="st">&quot;list&quot;</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="fu">ncol</span>(attitude) <span class="sc">-</span> <span class="dv">1</span>)) {</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  modeles[[i]] <span class="ot">&lt;-</span> <span class="fu">lm</span>(rating <span class="sc">~</span> ., <span class="at">data =</span> attitude[, <span class="fu">c</span>(<span class="dv">1</span>, i <span class="sc">+</span> <span class="dv">1</span>)])</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>modeles</span></code></pre></div>
<pre><code>## [[1]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)   complaints  
##     14.3763       0.7546  
## 
## 
## [[2]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)   privileges  
##     42.1087       0.4239  
## 
## 
## [[3]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)     learning  
##     28.1741       0.6468  
## 
## 
## [[4]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)       raises  
##     19.9778       0.6909  
## 
## 
## [[5]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)     critical  
##     50.2446       0.1924  
## 
## 
## [[6]]
## 
## Call:
## lm(formula = rating ~ ., data = attitude[, c(1, i + 1)])
## 
## Coefficients:
## (Intercept)      advance  
##     56.7558       0.1835</code></pre>
</div>
</div>
<div id="enregistrement-des-résultats-dans-une-boucle" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Enregistrement des résultats dans une boucle</h2>
<p>Une affectation de valeur à un endroit précis d’un objet (ex.: <code>modeles[[i]] &lt;- lm(...)</code>) nécessite que l’objet existe préalablement. Ainsi, une boucle est souvent précédée par l’initialisation d’un objet dédié à contenir les résultats calculés dans la boucle. Dans l’exemple précédent, nous avons initialisé la liste <code>modeles</code> avant la boucle par l’instruction :</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>modeles <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">length =</span> <span class="fu">ncol</span>(attitude) <span class="sc">-</span> <span class="dv">1</span>, <span class="at">mode =</span> <span class="st">&quot;list&quot;</span>)</span></code></pre></div>
<p>Remarquons que la fonction <code>vector</code> crée bien une liste ici, et non un vecteur, grâce à l’argument <code>mode = "list"</code>. Après tout, les listes sont des vecteurs récursifs.</p>
<p>Nous aurions pu choisir d’itérer sur les noms des variables explicatives plutôt que sur les entiers 1 à 6, comme suit :</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>modeles <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">length =</span> <span class="fu">ncol</span>(attitude) <span class="sc">-</span> <span class="dv">1</span>, <span class="at">mode =</span> <span class="st">&quot;list&quot;</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(modeles) <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(<span class="fu">names</span>(attitude), <span class="st">&quot;rating&quot;</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (variable <span class="cf">in</span> <span class="fu">names</span>(modeles)) {</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  modeles[[variable]] <span class="ot">&lt;-</span> <span class="fu">lm</span>(rating <span class="sc">~</span> ., <span class="at">data =</span> attitude[, <span class="fu">c</span>(<span class="st">&quot;rating&quot;</span>, variable)])</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Dans ce cas, nous avons préalablement nommé les éléments de la liste initialement vide. Ainsi, dans la boucle, nous pouvons référer à des éléments spécifiques de la liste <code>modeles</code> par leur nom plutôt que par leur indice.</p>
</div>
<div id="affichage-de-résultats-dans-une-boucle" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Affichage de résultats dans une boucle</h2>
<p>Voici une boucle très simple.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="dv">5</span>)) {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  i</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Si vous soumettez cette boucle, vous remarquerez qu’elle n’affiche rien. Pourtant, une instruction contenant uniquement le nom d’un objet affiche cet objet lorsque l’instruction est soumise dans la console.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>i</span></code></pre></div>
<pre><code>## [1] 5</code></pre>
<p>Ce résultat ne se produit pas dans une boucle. Il faut utiliser les fonctions <code>print</code> ou <code>cat</code> pour qu’un résultat soit affiché dans la console pendant l’exécution d’une boucle.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="dv">5</span>)) {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(i)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="dv">5</span>)) {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(i)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## 12345</code></pre>
<p><code>cat</code> est utile pour faire afficher une trace des itérations.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(<span class="dv">5</span>)) {</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">&quot;itération&quot;</span>, i, <span class="st">&quot;terminée</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## itération 1 terminée
## itération 2 terminée
## itération 3 terminée
## itération 4 terminée
## itération 5 terminée</code></pre>
<p>Rappel : Le caractère <code>\n</code> représente un retour à la ligne.</p>
</div>
<div id="boucles-while-ou-repeat" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Boucles <code>while</code> ou <code>repeat</code></h2>
<p>Parfois, le nombre d’itérations dépend d’une condition à rencontrer, il n’est pas prédéterminé. Les boucles R <code>while</code> et <code>repeat</code> sont utiles dans cette situation.</p>
<p><strong>Écriture générale d’une boucle <code>while</code></strong> :</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="sc">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées à chaque itération de la boucle</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><strong>Écriture générale d’une boucle <code>repeat</code></strong> :</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span> {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées à chaque itération de la boucle</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="er">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Un des intérêts d’une boucle <code>repeat</code> est de tester la condition après avoir exécuté les instructions et non avant comme dans une boucle <code>while</code>. Dans un boucle <code>repeat</code>, le mot-clé <code>break</code> doit être utilisé pour mettre fin aux itérations, sinon la boucle est infinie.</p>
<p>La <code>&lt;condition&gt;</code> doit encore une fois être une instruction qui retourne une seule valeur logique (<code>TRUE</code> ou <code>FALSE</code>).</p>
<p>Dans les écritures générales ci-dessus, remarquez qu’il y a un opérateur logique de négation devant la condition dans la boucle <code>repeat</code>. C’est pour mettre en évidence le fait qu’une boucle <code>while</code> continue d’itérer tant que <code>&lt;condition&gt;</code> demeure <code>TRUE</code>. Pour une même <code>&lt;condition&gt;</code>, il faut donc faire arrêter la boucle <code>repeat</code> lorsque <code>&lt;condition&gt;</code> devient <code>FALSE</code>.</p>
<p>Voici un exemple.</p>
<p>Nous souhaitons simuler le lancer d’un dé jusqu’à l’obtention d’un 6 et compter le nombre de lancers.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>resultat <span class="ot">&lt;-</span> <span class="dv">1</span>   <span class="co"># initialisation à un résultat quelconque, différent de 6</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>n_lancers <span class="ot">&lt;-</span> <span class="dv">0</span>  <span class="co"># initialisation à 0 du nombre de lancer</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (resultat <span class="sc">!=</span> <span class="dv">6</span>) {              <span class="co"># tant que le résultat n&#39;est pas égal à 6, répéter</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  resultat <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)  <span class="co"># simulation du lancer du dé</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  n_lancers <span class="ot">&lt;-</span> n_lancers <span class="sc">+</span> <span class="dv">1</span>         <span class="co"># incrémentation du nombre de lancers</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>n_lancers       <span class="co"># afficher le résultat final</span></span></code></pre></div>
<p>La boucle <code>while</code> peut être remplacée par une boucle <code>repeat</code> avec le mot-clé <code>break</code> comme suit.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>n_lancers <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span> {</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  resultat <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  n_lancers <span class="ot">&lt;-</span> n_lancers <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isTRUE</span>(resultat <span class="sc">==</span> <span class="dv">6</span>)) {</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>n_lancers</span></code></pre></div>
<p>Ici, nous n’avons pas besoin d’initialiser <code>resultat</code>, car la condition est évaluée à la fin de la boucle, après avoir calculé <code>resultat</code> au moins une fois.</p>
<p>Remarque : Si les instructions dans une boucle <code>while</code> ou <code>repeat</code> n’ont aucun impact sur la <code>&lt;condition&gt;</code> et que celle-ci demeure toujours vraie, alors la boucle est infinie. Il est important de s’assurer que la <code>&lt;condition&gt;</code> devienne éventuellement fausse, afin que la boucle puisse s’arrêter.</p>
</div>
<div id="imbriquer-des-boucles" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Imbriquer des boucles</h2>
<p>Dans l’exemple précédent, il serait intéressant de répéter l’expérience un grand nombre de fois et de calculer le nombre moyen de lancers requis pour obtenir un 6. Pour ce faire nous pourrions imbriquer la boucle <code>while</code> ou <code>repeat</code> dans une boucle <code>for</code> comme suit :</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>n_rep <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>n_lancers <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, n_rep)  <span class="co"># ou vector(length = n_rep, mode = &quot;numeric&quot;)</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_rep) {</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  resultat <span class="ot">&lt;-</span> <span class="dv">1</span> </span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (resultat <span class="sc">!=</span> <span class="dv">6</span>) {</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    resultat <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    n_lancers[i] <span class="ot">&lt;-</span> n_lancers[i] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(n_lancers)</span></code></pre></div>
<pre><code>## [1] 6.025</code></pre>
<p>Cet exemple montre une façon empirique d’estimer l’espérance d’une variable aléatoire suivant une <a href="https://fr.wikipedia.org/wiki/Loi_g%C3%A9om%C3%A9trique">distribution géométrique</a> de paramètre p = 1/6. Plus grand est le nombre de répétitions, plus l’estimation est précise (convergence). En théorie, cette espérance vaut 1/p = 6.</p>
<p>Il est simple d’imbriquer des boucles en R, peu importe leur type (<code>for</code>, <code>while</code> ou <code>repeat</code>). Cependant, nous verrons plus tard que plus l’imbrication possède de niveaux, plus le programme tend à être long à exécuter.</p>
</div>
<div id="mots-clés-break-et-next" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> Mots-clés <code>break</code> et <code>next</code></h2>
<p>Deux mots-clés existent pour contrôler l’exécution des instructions à l’intérieur d’une boucle :</p>
<ul>
<li><p><code>break</code> : pour terminer complètement l’exécution de la boucle (les itérations restantes ne sont pas effectuées).</p></li>
<li><p><code>next</code> : pour terminer immédiatement une itération (sans exécuter les instructions après le mot-clé <code>next</code>) et reprendre l’exécution de la boucle à la prochaine itération.</p></li>
</ul>
<p>Ces deux mot-clés sont pratiquement toujours utilisés dans une structure <code>if</code>.</p>
<p>Le mot-clé <code>break</code> a déjà été illustré dans une boucle <code>repeat</code>. Notons cependant que nous pouvons l’utiliser dans une boucle de n’importe quel type.</p>
<p>Illustrons maintenant l’utilisation du mot-clé <code>next</code>. Reprenons l’exemple de l’affichage des lettres de l’alphabet. Supposons que nous souhaitons afficher seulement les consonnes.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (lettre <span class="cf">in</span> LETTERS) {</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isTRUE</span>(lettre <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;O&quot;</span>, <span class="st">&quot;U&quot;</span>))) {</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">next</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(lettre, <span class="st">&quot; &quot;</span>)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## B  C  D  F  G  H  J  K  L  M  N  P  Q  R  S  T  V  W  X  Y  Z</code></pre>
<p>Dans ce programme, si la condition <code>isTRUE(lettre %in% c("A", "E", "I", "O", "U"))</code> est rencontrée, nous passons à l’itération suivante de la boucle, sans soumettre l’instruction <code>cat(lettre, " ")</code>. Le mot-clé <code>next</code> permet donc d’omettre l’exécution de certaines instructions.</p>
<p>En fait, le dernier programme fait la même chose que le programme suivant.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (lettre <span class="cf">in</span> LETTERS) {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isFALSE</span>(lettre <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;O&quot;</span>, <span class="st">&quot;U&quot;</span>))) {</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(lettre, <span class="st">&quot; &quot;</span>)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## B  C  D  F  G  H  J  K  L  M  N  P  Q  R  S  T  V  W  X  Y  Z</code></pre>
<p>Ici, il n’y a plus de mot-clé <code>next</code>, mais l’instruction <code>cat(lettre, " ")</code> est dans le <code>if</code> plutôt qu’après le <code>if</code>.</p>
<p>Nous avons souvent constaté qu’il y a plusieurs façons de réaliser une même tâche en R. Cette remarque est aussi vraie pour les boucles.</p>
</div>
<div id="interruption-de-lexécution-dune-boucle" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> Interruption de l’exécution d’une boucle</h2>
<p>Il peut arriver que, par erreur, nous soumettions en R une boucle vraiment longue à rouler, possiblement infinie. En RStudio, l’exécution de n’importe quelle commande, incluant une boucle, peut être interrompue d’une des façons suivantes :</p>
<ul>
<li>la touche « Esc »,</li>
<li>le bouton STOP en entête à droite de la sous-fenêtre de la console R (dans un petit logo de panneau d’arrêt rouge de forme octogonale),</li>
<li>le menu « Session &gt; Interrupt R ».</li>
</ul>
</div>
<div id="éviter-les-boucles" class="section level2" number="2.8">
<h2><span class="header-section-number">2.8</span> Éviter les boucles</h2>
<p>Une des philosophies de base en programmation R est d’utiliser une boucle seulement si celle-ci est vraiment nécessaire pour réaliser la tâche à accomplir. Le fonctionnement vectoriel de plusieurs fonctions R, ainsi que les fonctions de la famille des <code>apply</code>, permettent bien souvent d’éviter l’utilisation d’une boucle.</p>
<p>Cette philosophie se base sur les faits suivants :</p>
<ul>
<li>le calcul vectoriel est plus rapide que les boucles;</li>
<li>éviter les boucles produit habituellement un code plus court, donc plus rapide à écrire et aussi potentiellement plus facile à comprendre.</li>
</ul>
<div id="calcul-vectoriel-versus-boucle" class="section level3" number="2.8.1">
<h3><span class="header-section-number">2.8.1</span> Calcul vectoriel versus boucle</h3>
<p>Voici un exemple simple d’opération vectorielle. Supposons que nous avons le vecteur numérique <code>x</code> suivant.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span></code></pre></div>
<p>Nous voulons élever au carré toutes les valeurs dans ce vecteur. En R, il est recommandé de réaliser cette tâche comme suit :</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>z <span class="ot">&lt;-</span> x<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>z</span></code></pre></div>
<pre><code>##  [1]   1   4   9  16  25  36  49  64  81 100</code></pre>
<p>Dans bien des langages informatiques, il aura fallu faire une boucle, telle que celle-ci :</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">length =</span> <span class="fu">length</span>(x), <span class="at">mode =</span> <span class="st">&quot;numeric&quot;</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(x)) {</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  z[i] <span class="ot">&lt;-</span> x[i]<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>z</span></code></pre></div>
<pre><code>##  [1]   1   4   9  16  25  36  49  64  81 100</code></pre>
<p>Laquelle des deux solutions vous paraît la plus simple à comprendre?</p>
</div>
<div id="fonction-de-la-famille-des-apply-versus-boucle" class="section level3" number="2.8.2">
<h3><span class="header-section-number">2.8.2</span> Fonction de la famille des <code>apply</code> versus boucle</h3>
<p>Voici un exemple simple d’utilisation d’une fonction de la famille des <code>apply</code>. Supposons que nous avons la matrice numérique <code>mat</code> suivante.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">nrow =</span> <span class="dv">4</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>mat</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12</code></pre>
<p>Nous voulons calculer les sommes des valeurs par colonne. En R, il est recommandé de réaliser cette tâche comme suit :</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>sommesColonnes <span class="ot">&lt;-</span> <span class="fu">colSums</span>(mat)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>sommesColonnes</span></code></pre></div>
<pre><code>## [1] 10 26 42</code></pre>
<p>La fonction <code>colSums</code> revient à un appel à la fonction <code>apply</code> optimisé pour la tâche spécifique du calcul de sommes en colonnes.</p>
<p>Dans bien des langages informatiques, il aurait fallu faire une boucle, telle que celle-ci :</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>sommesColonnes <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">length =</span> <span class="fu">ncol</span>(mat), <span class="at">mode =</span> <span class="st">&quot;numeric&quot;</span>)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(mat)) {</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>  sommesColonnes[i] <span class="ot">&lt;-</span> <span class="fu">sum</span>(mat[, i])</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>sommesColonnes</span></code></pre></div>
<pre><code>## [1] 10 26 42</code></pre>
<p>En termes de temps de travail requis pour écrire le code, il est plus rapide d’appeler la fonction <code>colSums</code> que d’écrire cette boucle. Aussi, le code avec l’appel à la fonction <code>colSums</code> est plus succinct, donc potentiellement plus simple à comprendre.</p>
<hr />
</div>
</div>
</div>
<div id="résumé" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Résumé</h1>
<div id="alternatives-1" class="section level4 unnumbered">
<h4>Alternatives</h4>
<div id="structure-if-...-else-1" class="section level5 unnumbered">
<h5>Structure <code>if ... else</code></h5>
<p></p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a> <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition&gt; est TRUE</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a> <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span>  <span class="co"># exécutées si &lt;condition&gt; est FALSE</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li><code>&lt;condition&gt;</code> = expression qui retourne <em>un seul logique</em> (<code>TRUE</code> ou <code>FALSE</code>).</li>
</ul>
<p>Écriture condensée d’une alternative :</p>
<pre><code>x &lt;- if (&lt;condition&gt;) &lt;instruction&gt; else &lt;instruction&gt;</code></pre>
<ul>
<li>Ce n’est pas la même chose que la fonction <code>ifelse</code>, qui travaille de façon vectorielle.</li>
</ul>
</div>
<div id="fonction-switch-1" class="section level5 unnumbered">
<h5>Fonction <code>switch</code></h5>
<p></p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span>(</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>expression<span class="sc">&gt;</span>,</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;resultat_1&quot;</span> <span class="ot">=</span> {</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne &quot;resultat_1&quot;</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;resultat_2&quot;</span> <span class="ot">=</span> {</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne &quot;resultat_2&quot;</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>  .</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>  .  <span class="co"># autres paires (résultat, instructions à exécuter) s&#39;il y a lieu</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>  .</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span> <span class="co"># exécutées si &lt;expression&gt; retourne tout autre résultat</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="boucles-1" class="section level4 unnumbered">
<h4>Boucles</h4>
<p></p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="sc">&lt;</span>iterateur<span class="sc">&gt;</span> <span class="cf">in</span> <span class="sc">&lt;</span>ensemble<span class="sc">&gt;</span>) {</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="sc">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span> {</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>  <span class="sc">&lt;</span>instructions<span class="sc">&gt;</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="er">&lt;</span>condition<span class="sc">&gt;</span>) {</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li><code>for</code> : boucle ayant un nombre prédéterminé d’itérations,</li>
<li><code>while</code> : boucle arrêtant lorsqu’une condition n’est plus rencontrée,</li>
<li><code>repeat</code> : boucle nécessitant le mot-clé <code>break</code> pour arrêter,</li>
<li><code>break</code> : mot-clé pour terminer l’exécution de la boucle,</li>
<li><code>next</code> : mot-clé pour sauter à la prochaine itération sans exécuter les instructions après le mot-clé.</li>
</ul>
<p><strong>À noter</strong> :</p>
<ul>
<li>Une boucle est souvent précédée par l’initialisation d’un objet dédié à contenir les résultats calculés dans la boucle.</li>
<li>Il faut utiliser les fonctions <code>print</code> ou <code>cat</code> pour qu’un résultat soit affiché dans la console pendant l’exécution d’une boucle.</li>
<li>Il est recommandé d’utiliser des boucles seulement si nécessaire, de favoriser les calculs vectoriels et l’utilisation des fonctions de la famille des <code>apply</code>.</li>
</ul>
<hr />
</div>
</div>
<div id="références" class="section level1 unnumbered">
<h1>Références</h1>
<ul>
<li>Matloff, N. (2011). <em>The Art of R Programming: A Tour of Statistical Software Design</em>. No Starch Press. Chapitre 7.</li>
<li>Grolemund, G. et Wickham, H. (2016). <em>R for Data Science</em>. O’Reilly Media, Inc. :
<ul>
<li>Alternatives : Section 19.4 <a href="http://r4ds.had.co.nz/functions.html#conditional-execution" class="uri">http://r4ds.had.co.nz/functions.html#conditional-execution</a></li>
<li>Boucles : Chapitre 21 <a href="http://r4ds.had.co.nz/iteration.html" class="uri">http://r4ds.had.co.nz/iteration.html</a></li>
</ul></li>
<li>Sections du tutoriel web intitulé « Learn R Programming » :
<ul>
<li>Alternatives : <a href="https://www.datamentor.io/r-programming/if-else-statement" class="uri">https://www.datamentor.io/r-programming/if-else-statement</a></li>
<li>Boucles <code>for</code> : <a href="https://www.datamentor.io/r-programming/for-loop" class="uri">https://www.datamentor.io/r-programming/for-loop</a></li>
<li>Boucles <code>while</code> : <a href="https://www.datamentor.io/r-programming/while-loop" class="uri">https://www.datamentor.io/r-programming/while-loop</a></li>
<li>Boucles <code>repeat</code> : <a href="https://www.datamentor.io/r-programming/repeat-loop" class="uri">https://www.datamentor.io/r-programming/repeat-loop</a></li>
</ul></li>
<li>Fanara, C. (2018). Tutoriel web intitulé « A Tutorial on Loops in R - Usage and Alternatives ». <a href="https://www.datacamp.com/community/tutorials/tutorial-on-loops-in-r" class="uri">https://www.datacamp.com/community/tutorials/tutorial-on-loops-in-r</a></li>
</ul>
</div>
